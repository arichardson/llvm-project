; NOTE: Assertions have been autogenerated by utils/update_test_checks.py UTC_ARGS: --function-signature --scrub-attributes --force-update
;; Check folds for CHERI intrinsics that have both get and set variants
; RUN: sed 's/INTRINSIC/address/' %s | opt -S -passes=instsimplify | FileCheck %s --check-prefixes=ADDRESS
; RUN: sed 's/INTRINSIC/flags/' %s | opt -S -passes=instsimplify | FileCheck %s --check-prefixes=FLAGS
; RUN: sed 's/INTRINSIC/high/' %s | opt -S -passes=instsimplify | FileCheck %s --check-prefixes=HIGH
; RUN: sed 's/INTRINSIC/offset/' %s | opt -S -passes=instsimplify | FileCheck %s --check-prefixes=OFFSET
target datalayout = "pf200:128:128:128:64-A200-P200-G200"

declare i64 @check_fold(i64) nounwind
declare i64 @llvm.cheri.cap.INTRINSIC.get.i64(i8 addrspace(200)*) nounwind
declare i8 addrspace(200)* @llvm.cheri.cap.INTRINSIC.set.i64(i8 addrspace(200)*, i64) nounwind


;; This is a no-op and should be folded to ret %arg
;; NB: The exception here is @llvm.cheri.cap.high.set since it is tag-clearing
;; and therefore could only be used on known-untagged values.
define i8 addrspace(200)* @fold_set_of_get(i8 addrspace(200)* %arg) nounwind {
; ADDRESS-LABEL: define {{[^@]+}}@fold_set_of_get
; ADDRESS-SAME: (i8 addrspace(200)* [[ARG:%.*]]) addrspace(200) #[[ATTR0:[0-9]+]] {
; ADDRESS-NEXT:    ret i8 addrspace(200)* [[ARG]]
;
; FLAGS-LABEL: define {{[^@]+}}@fold_set_of_get
; FLAGS-SAME: (i8 addrspace(200)* [[ARG:%.*]]) addrspace(200) #[[ATTR0:[0-9]+]] {
; FLAGS-NEXT:    ret i8 addrspace(200)* [[ARG]]
;
; HIGH-LABEL: define {{[^@]+}}@fold_set_of_get
; HIGH-SAME: (i8 addrspace(200)* [[ARG:%.*]]) addrspace(200) #[[ATTR0:[0-9]+]] {
; HIGH-NEXT:    [[VALUE:%.*]] = tail call i64 @llvm.cheri.cap.high.get.i64(i8 addrspace(200)* [[ARG]])
; HIGH-NEXT:    [[RET:%.*]] = tail call i8 addrspace(200)* @llvm.cheri.cap.high.set.i64(i8 addrspace(200)* [[ARG]], i64 [[VALUE]])
; HIGH-NEXT:    ret i8 addrspace(200)* [[RET]]
;
; OFFSET-LABEL: define {{[^@]+}}@fold_set_of_get
; OFFSET-SAME: (i8 addrspace(200)* [[ARG:%.*]]) addrspace(200) #[[ATTR0:[0-9]+]] {
; OFFSET-NEXT:    ret i8 addrspace(200)* [[ARG]]
;
  %value = tail call i64 @llvm.cheri.cap.INTRINSIC.get.i64(i8 addrspace(200)* %arg)
  %ret = tail call i8 addrspace(200)* @llvm.cheri.cap.INTRINSIC.set.i64(i8 addrspace(200)* %arg, i64 %value)
  ret i8 addrspace(200)* %ret
}

;; negative test - get of a different value should not be folded to ret %arg
define i8 addrspace(200)* @fold_set_of_get_bad(i8 addrspace(200)* %arg, i8 addrspace(200)* %other) nounwind {
; ADDRESS-LABEL: define {{[^@]+}}@fold_set_of_get_bad
; ADDRESS-SAME: (i8 addrspace(200)* [[ARG:%.*]], i8 addrspace(200)* [[OTHER:%.*]]) addrspace(200) #[[ATTR0]] {
; ADDRESS-NEXT:    [[VALUE:%.*]] = tail call i64 @llvm.cheri.cap.address.get.i64(i8 addrspace(200)* [[OTHER]])
; ADDRESS-NEXT:    [[RET:%.*]] = tail call i8 addrspace(200)* @llvm.cheri.cap.address.set.i64(i8 addrspace(200)* [[ARG]], i64 [[VALUE]])
; ADDRESS-NEXT:    ret i8 addrspace(200)* [[RET]]
;
; FLAGS-LABEL: define {{[^@]+}}@fold_set_of_get_bad
; FLAGS-SAME: (i8 addrspace(200)* [[ARG:%.*]], i8 addrspace(200)* [[OTHER:%.*]]) addrspace(200) #[[ATTR0]] {
; FLAGS-NEXT:    [[VALUE:%.*]] = tail call i64 @llvm.cheri.cap.flags.get.i64(i8 addrspace(200)* [[OTHER]])
; FLAGS-NEXT:    [[RET:%.*]] = tail call i8 addrspace(200)* @llvm.cheri.cap.flags.set.i64(i8 addrspace(200)* [[ARG]], i64 [[VALUE]])
; FLAGS-NEXT:    ret i8 addrspace(200)* [[RET]]
;
; HIGH-LABEL: define {{[^@]+}}@fold_set_of_get_bad
; HIGH-SAME: (i8 addrspace(200)* [[ARG:%.*]], i8 addrspace(200)* [[OTHER:%.*]]) addrspace(200) #[[ATTR0]] {
; HIGH-NEXT:    [[VALUE:%.*]] = tail call i64 @llvm.cheri.cap.high.get.i64(i8 addrspace(200)* [[OTHER]])
; HIGH-NEXT:    [[RET:%.*]] = tail call i8 addrspace(200)* @llvm.cheri.cap.high.set.i64(i8 addrspace(200)* [[ARG]], i64 [[VALUE]])
; HIGH-NEXT:    ret i8 addrspace(200)* [[RET]]
;
; OFFSET-LABEL: define {{[^@]+}}@fold_set_of_get_bad
; OFFSET-SAME: (i8 addrspace(200)* [[ARG:%.*]], i8 addrspace(200)* [[OTHER:%.*]]) addrspace(200) #[[ATTR0]] {
; OFFSET-NEXT:    [[VALUE:%.*]] = tail call i64 @llvm.cheri.cap.offset.get.i64(i8 addrspace(200)* [[OTHER]])
; OFFSET-NEXT:    [[RET:%.*]] = tail call i8 addrspace(200)* @llvm.cheri.cap.offset.set.i64(i8 addrspace(200)* [[ARG]], i64 [[VALUE]])
; OFFSET-NEXT:    ret i8 addrspace(200)* [[RET]]
;
  %value = tail call i64 @llvm.cheri.cap.INTRINSIC.get.i64(i8 addrspace(200)* %other)
  %ret = tail call i8 addrspace(200)* @llvm.cheri.cap.INTRINSIC.set.i64(i8 addrspace(200)* %arg, i64 %value)
  ret i8 addrspace(200)* %ret
}

;; For almost all intrinsics this get-of-set pair can be elided
;; NB: This is not true for flags where the value written by set could be truncated to another value
;; FIXME: high.get should be folded.
define i64 @fold_get_of_set(i8 addrspace(200)* %arg, i64 %value) nounwind {
; ADDRESS-LABEL: define {{[^@]+}}@fold_get_of_set
; ADDRESS-SAME: (i8 addrspace(200)* [[ARG:%.*]], i64 [[VALUE:%.*]]) addrspace(200) #[[ATTR0]] {
; ADDRESS-NEXT:    ret i64 [[VALUE]]
;
; FLAGS-LABEL: define {{[^@]+}}@fold_get_of_set
; FLAGS-SAME: (i8 addrspace(200)* [[ARG:%.*]], i64 [[VALUE:%.*]]) addrspace(200) #[[ATTR0]] {
; FLAGS-NEXT:    [[MODIFIED:%.*]] = tail call i8 addrspace(200)* @llvm.cheri.cap.flags.set.i64(i8 addrspace(200)* [[ARG]], i64 [[VALUE]])
; FLAGS-NEXT:    [[RET:%.*]] = tail call i64 @llvm.cheri.cap.flags.get.i64(i8 addrspace(200)* [[MODIFIED]])
; FLAGS-NEXT:    ret i64 [[RET]]
;
; HIGH-LABEL: define {{[^@]+}}@fold_get_of_set
; HIGH-SAME: (i8 addrspace(200)* [[ARG:%.*]], i64 [[VALUE:%.*]]) addrspace(200) #[[ATTR0]] {
; HIGH-NEXT:    ret i64 [[VALUE]]
;
; OFFSET-LABEL: define {{[^@]+}}@fold_get_of_set
; OFFSET-SAME: (i8 addrspace(200)* [[ARG:%.*]], i64 [[VALUE:%.*]]) addrspace(200) #[[ATTR0]] {
; OFFSET-NEXT:    [[MODIFIED:%.*]] = tail call i8 addrspace(200)* @llvm.cheri.cap.offset.set.i64(i8 addrspace(200)* [[ARG]], i64 [[VALUE]])
; OFFSET-NEXT:    [[RET:%.*]] = tail call i64 @llvm.cheri.cap.offset.get.i64(i8 addrspace(200)* [[MODIFIED]])
; OFFSET-NEXT:    ret i64 [[RET]]
;
  %modified = tail call i8 addrspace(200)* @llvm.cheri.cap.INTRINSIC.set.i64(i8 addrspace(200)* %arg, i64 %value)
  %ret = tail call i64 @llvm.cheri.cap.INTRINSIC.get.i64(i8 addrspace(200)* %modified)
  ret i64 %ret
}

;; Negative test -- get is used on other intrinsic
define i64 @fold_get_of_set_bad(i8 addrspace(200)* %arg, i8 addrspace(200)* %other, i64 %value) nounwind {
; ADDRESS-LABEL: define {{[^@]+}}@fold_get_of_set_bad
; ADDRESS-SAME: (i8 addrspace(200)* [[ARG:%.*]], i8 addrspace(200)* [[OTHER:%.*]], i64 [[VALUE:%.*]]) addrspace(200) #[[ATTR0]] {
; ADDRESS-NEXT:    [[RET:%.*]] = tail call i64 @llvm.cheri.cap.address.get.i64(i8 addrspace(200)* [[ARG]])
; ADDRESS-NEXT:    ret i64 [[RET]]
;
; FLAGS-LABEL: define {{[^@]+}}@fold_get_of_set_bad
; FLAGS-SAME: (i8 addrspace(200)* [[ARG:%.*]], i8 addrspace(200)* [[OTHER:%.*]], i64 [[VALUE:%.*]]) addrspace(200) #[[ATTR0]] {
; FLAGS-NEXT:    [[RET:%.*]] = tail call i64 @llvm.cheri.cap.flags.get.i64(i8 addrspace(200)* [[ARG]])
; FLAGS-NEXT:    ret i64 [[RET]]
;
; HIGH-LABEL: define {{[^@]+}}@fold_get_of_set_bad
; HIGH-SAME: (i8 addrspace(200)* [[ARG:%.*]], i8 addrspace(200)* [[OTHER:%.*]], i64 [[VALUE:%.*]]) addrspace(200) #[[ATTR0]] {
; HIGH-NEXT:    [[RET:%.*]] = tail call i64 @llvm.cheri.cap.high.get.i64(i8 addrspace(200)* [[ARG]])
; HIGH-NEXT:    ret i64 [[RET]]
;
; OFFSET-LABEL: define {{[^@]+}}@fold_get_of_set_bad
; OFFSET-SAME: (i8 addrspace(200)* [[ARG:%.*]], i8 addrspace(200)* [[OTHER:%.*]], i64 [[VALUE:%.*]]) addrspace(200) #[[ATTR0]] {
; OFFSET-NEXT:    [[RET:%.*]] = tail call i64 @llvm.cheri.cap.offset.get.i64(i8 addrspace(200)* [[ARG]])
; OFFSET-NEXT:    ret i64 [[RET]]
;
  %modified = tail call i8 addrspace(200)* @llvm.cheri.cap.INTRINSIC.set.i64(i8 addrspace(200)* %other, i64 %value)
  %ret = tail call i64 @llvm.cheri.cap.INTRINSIC.get.i64(i8 addrspace(200)* %arg)
  ret i64 %ret
}

define i64 @fold_get_on_null() nounwind {
; ADDRESS-LABEL: define {{[^@]+}}@fold_get_on_null
; ADDRESS-SAME: () addrspace(200) #[[ATTR0]] {
; ADDRESS-NEXT:    ret i64 0
;
; FLAGS-LABEL: define {{[^@]+}}@fold_get_on_null
; FLAGS-SAME: () addrspace(200) #[[ATTR0]] {
; FLAGS-NEXT:    ret i64 0
;
; HIGH-LABEL: define {{[^@]+}}@fold_get_on_null
; HIGH-SAME: () addrspace(200) #[[ATTR0]] {
; HIGH-NEXT:    ret i64 0
;
; OFFSET-LABEL: define {{[^@]+}}@fold_get_on_null
; OFFSET-SAME: () addrspace(200) #[[ATTR0]] {
; OFFSET-NEXT:    ret i64 0
;
  %ret = tail call i64 @llvm.cheri.cap.INTRINSIC.get.i64(i8 addrspace(200)* null)
  ret i64 %ret
}

define i64 @fold_get_on_null_with_gep(i64 %value, i64 %gepoff) nounwind {
; ADDRESS-LABEL: define {{[^@]+}}@fold_get_on_null_with_gep
; ADDRESS-SAME: (i64 [[VALUE:%.*]], i64 [[GEPOFF:%.*]]) addrspace(200) #[[ATTR0]] {
; ADDRESS-NEXT:    ret i64 [[GEPOFF]]
;
; FLAGS-LABEL: define {{[^@]+}}@fold_get_on_null_with_gep
; FLAGS-SAME: (i64 [[VALUE:%.*]], i64 [[GEPOFF:%.*]]) addrspace(200) #[[ATTR0]] {
; FLAGS-NEXT:    ret i64 0
;
; HIGH-LABEL: define {{[^@]+}}@fold_get_on_null_with_gep
; HIGH-SAME: (i64 [[VALUE:%.*]], i64 [[GEPOFF:%.*]]) addrspace(200) #[[ATTR0]] {
; HIGH-NEXT:    ret i64 0
;
; OFFSET-LABEL: define {{[^@]+}}@fold_get_on_null_with_gep
; OFFSET-SAME: (i64 [[VALUE:%.*]], i64 [[GEPOFF:%.*]]) addrspace(200) #[[ATTR0]] {
; OFFSET-NEXT:    ret i64 [[GEPOFF]]
;
  %tmp = getelementptr i8, i8 addrspace(200)* null, i64 %gepoff
  %ret = tail call i64 @llvm.cheri.cap.INTRINSIC.get.i64(i8 addrspace(200)* %tmp)
  ret i64 %ret
}

;; TODO: Setting is idempotent, so the first call should be elided
define i8 addrspace(200)* @set_idempotent(i8 addrspace(200)* %arg, i64 %value) nounwind {
; ADDRESS-LABEL: define {{[^@]+}}@set_idempotent
; ADDRESS-SAME: (i8 addrspace(200)* [[ARG:%.*]], i64 [[VALUE:%.*]]) addrspace(200) #[[ATTR0]] {
; ADDRESS-NEXT:    [[MODIFIED:%.*]] = tail call i8 addrspace(200)* @llvm.cheri.cap.address.set.i64(i8 addrspace(200)* [[ARG]], i64 [[VALUE]])
; ADDRESS-NEXT:    [[RET:%.*]] = tail call i8 addrspace(200)* @llvm.cheri.cap.address.set.i64(i8 addrspace(200)* [[MODIFIED]], i64 [[VALUE]])
; ADDRESS-NEXT:    ret i8 addrspace(200)* [[RET]]
;
; FLAGS-LABEL: define {{[^@]+}}@set_idempotent
; FLAGS-SAME: (i8 addrspace(200)* [[ARG:%.*]], i64 [[VALUE:%.*]]) addrspace(200) #[[ATTR0]] {
; FLAGS-NEXT:    [[MODIFIED:%.*]] = tail call i8 addrspace(200)* @llvm.cheri.cap.flags.set.i64(i8 addrspace(200)* [[ARG]], i64 [[VALUE]])
; FLAGS-NEXT:    [[RET:%.*]] = tail call i8 addrspace(200)* @llvm.cheri.cap.flags.set.i64(i8 addrspace(200)* [[MODIFIED]], i64 [[VALUE]])
; FLAGS-NEXT:    ret i8 addrspace(200)* [[RET]]
;
; HIGH-LABEL: define {{[^@]+}}@set_idempotent
; HIGH-SAME: (i8 addrspace(200)* [[ARG:%.*]], i64 [[VALUE:%.*]]) addrspace(200) #[[ATTR0]] {
; HIGH-NEXT:    [[MODIFIED:%.*]] = tail call i8 addrspace(200)* @llvm.cheri.cap.high.set.i64(i8 addrspace(200)* [[ARG]], i64 [[VALUE]])
; HIGH-NEXT:    [[RET:%.*]] = tail call i8 addrspace(200)* @llvm.cheri.cap.high.set.i64(i8 addrspace(200)* [[MODIFIED]], i64 [[VALUE]])
; HIGH-NEXT:    ret i8 addrspace(200)* [[RET]]
;
; OFFSET-LABEL: define {{[^@]+}}@set_idempotent
; OFFSET-SAME: (i8 addrspace(200)* [[ARG:%.*]], i64 [[VALUE:%.*]]) addrspace(200) #[[ATTR0]] {
; OFFSET-NEXT:    [[MODIFIED:%.*]] = tail call i8 addrspace(200)* @llvm.cheri.cap.offset.set.i64(i8 addrspace(200)* [[ARG]], i64 [[VALUE]])
; OFFSET-NEXT:    [[RET:%.*]] = tail call i8 addrspace(200)* @llvm.cheri.cap.offset.set.i64(i8 addrspace(200)* [[MODIFIED]], i64 [[VALUE]])
; OFFSET-NEXT:    ret i8 addrspace(200)* [[RET]]
;
  %modified = tail call i8 addrspace(200)* @llvm.cheri.cap.INTRINSIC.set.i64(i8 addrspace(200)* %arg, i64 %value)
  %ret = tail call i8 addrspace(200)* @llvm.cheri.cap.INTRINSIC.set.i64(i8 addrspace(200)* %modified, i64 %value)
  ret i8 addrspace(200)* %ret
}


;; Negative test - calls with the same base argument are not yet elided if the
;; second argument is different since they could have side-effects such as
;; clearing the tag. For example `setoffset(setoffset(x, <LARGE>), <SMALL>)`
;; would result in an untagged value if the first setoffset went outside the
;; representable range but that detagging would not happen if we elide it.
;; TODO: Maybe we should do this fold since people should not be relying on
;; representability to clear tags of capabilities.
define i8 addrspace(200)* @set_different_values(i8 addrspace(200)* %arg, i64 %value, i64 %value2) nounwind {
; ADDRESS-LABEL: define {{[^@]+}}@set_different_values
; ADDRESS-SAME: (i8 addrspace(200)* [[ARG:%.*]], i64 [[VALUE:%.*]], i64 [[VALUE2:%.*]]) addrspace(200) #[[ATTR0]] {
; ADDRESS-NEXT:    [[MODIFIED:%.*]] = tail call i8 addrspace(200)* @llvm.cheri.cap.address.set.i64(i8 addrspace(200)* [[ARG]], i64 [[VALUE]])
; ADDRESS-NEXT:    [[RET:%.*]] = tail call i8 addrspace(200)* @llvm.cheri.cap.address.set.i64(i8 addrspace(200)* [[MODIFIED]], i64 [[VALUE]])
; ADDRESS-NEXT:    ret i8 addrspace(200)* [[RET]]
;
; FLAGS-LABEL: define {{[^@]+}}@set_different_values
; FLAGS-SAME: (i8 addrspace(200)* [[ARG:%.*]], i64 [[VALUE:%.*]], i64 [[VALUE2:%.*]]) addrspace(200) #[[ATTR0]] {
; FLAGS-NEXT:    [[MODIFIED:%.*]] = tail call i8 addrspace(200)* @llvm.cheri.cap.flags.set.i64(i8 addrspace(200)* [[ARG]], i64 [[VALUE]])
; FLAGS-NEXT:    [[RET:%.*]] = tail call i8 addrspace(200)* @llvm.cheri.cap.flags.set.i64(i8 addrspace(200)* [[MODIFIED]], i64 [[VALUE]])
; FLAGS-NEXT:    ret i8 addrspace(200)* [[RET]]
;
; HIGH-LABEL: define {{[^@]+}}@set_different_values
; HIGH-SAME: (i8 addrspace(200)* [[ARG:%.*]], i64 [[VALUE:%.*]], i64 [[VALUE2:%.*]]) addrspace(200) #[[ATTR0]] {
; HIGH-NEXT:    [[MODIFIED:%.*]] = tail call i8 addrspace(200)* @llvm.cheri.cap.high.set.i64(i8 addrspace(200)* [[ARG]], i64 [[VALUE]])
; HIGH-NEXT:    [[RET:%.*]] = tail call i8 addrspace(200)* @llvm.cheri.cap.high.set.i64(i8 addrspace(200)* [[MODIFIED]], i64 [[VALUE]])
; HIGH-NEXT:    ret i8 addrspace(200)* [[RET]]
;
; OFFSET-LABEL: define {{[^@]+}}@set_different_values
; OFFSET-SAME: (i8 addrspace(200)* [[ARG:%.*]], i64 [[VALUE:%.*]], i64 [[VALUE2:%.*]]) addrspace(200) #[[ATTR0]] {
; OFFSET-NEXT:    [[MODIFIED:%.*]] = tail call i8 addrspace(200)* @llvm.cheri.cap.offset.set.i64(i8 addrspace(200)* [[ARG]], i64 [[VALUE]])
; OFFSET-NEXT:    [[RET:%.*]] = tail call i8 addrspace(200)* @llvm.cheri.cap.offset.set.i64(i8 addrspace(200)* [[MODIFIED]], i64 [[VALUE]])
; OFFSET-NEXT:    ret i8 addrspace(200)* [[RET]]
;
  %modified = tail call i8 addrspace(200)* @llvm.cheri.cap.INTRINSIC.set.i64(i8 addrspace(200)* %arg, i64 %value)
  %ret = tail call i8 addrspace(200)* @llvm.cheri.cap.INTRINSIC.set.i64(i8 addrspace(200)* %modified, i64 %value)
  ret i8 addrspace(200)* %ret
}

define i8 addrspace(200)* @fold_set_on_null(i64 %value) nounwind {
; ADDRESS-LABEL: define {{[^@]+}}@fold_set_on_null
; ADDRESS-SAME: (i64 [[VALUE:%.*]]) addrspace(200) #[[ATTR0]] {
; ADDRESS-NEXT:    [[RET:%.*]] = tail call i8 addrspace(200)* @llvm.cheri.cap.address.set.i64(i8 addrspace(200)* null, i64 [[VALUE]])
; ADDRESS-NEXT:    ret i8 addrspace(200)* [[RET]]
;
; FLAGS-LABEL: define {{[^@]+}}@fold_set_on_null
; FLAGS-SAME: (i64 [[VALUE:%.*]]) addrspace(200) #[[ATTR0]] {
; FLAGS-NEXT:    [[RET:%.*]] = tail call i8 addrspace(200)* @llvm.cheri.cap.flags.set.i64(i8 addrspace(200)* null, i64 [[VALUE]])
; FLAGS-NEXT:    ret i8 addrspace(200)* [[RET]]
;
; HIGH-LABEL: define {{[^@]+}}@fold_set_on_null
; HIGH-SAME: (i64 [[VALUE:%.*]]) addrspace(200) #[[ATTR0]] {
; HIGH-NEXT:    [[RET:%.*]] = tail call i8 addrspace(200)* @llvm.cheri.cap.high.set.i64(i8 addrspace(200)* null, i64 [[VALUE]])
; HIGH-NEXT:    ret i8 addrspace(200)* [[RET]]
;
; OFFSET-LABEL: define {{[^@]+}}@fold_set_on_null
; OFFSET-SAME: (i64 [[VALUE:%.*]]) addrspace(200) #[[ATTR0]] {
; OFFSET-NEXT:    [[RET:%.*]] = tail call i8 addrspace(200)* @llvm.cheri.cap.offset.set.i64(i8 addrspace(200)* null, i64 [[VALUE]])
; OFFSET-NEXT:    ret i8 addrspace(200)* [[RET]]
;
  %ret = tail call i8 addrspace(200)* @llvm.cheri.cap.INTRINSIC.set.i64(i8 addrspace(200)* null, i64 %value)
  ret i8 addrspace(200)* %ret
}

define i8 addrspace(200)* @fold_set_on_null_with_gep(i64 %value, i64 %gepoff) nounwind {
; ADDRESS-LABEL: define {{[^@]+}}@fold_set_on_null_with_gep
; ADDRESS-SAME: (i64 [[VALUE:%.*]], i64 [[GEPOFF:%.*]]) addrspace(200) #[[ATTR0]] {
; ADDRESS-NEXT:    [[TMP:%.*]] = getelementptr i8, i8 addrspace(200)* null, i64 [[GEPOFF]]
; ADDRESS-NEXT:    [[RET:%.*]] = tail call i8 addrspace(200)* @llvm.cheri.cap.address.set.i64(i8 addrspace(200)* [[TMP]], i64 [[VALUE]])
; ADDRESS-NEXT:    ret i8 addrspace(200)* [[RET]]
;
; FLAGS-LABEL: define {{[^@]+}}@fold_set_on_null_with_gep
; FLAGS-SAME: (i64 [[VALUE:%.*]], i64 [[GEPOFF:%.*]]) addrspace(200) #[[ATTR0]] {
; FLAGS-NEXT:    [[TMP:%.*]] = getelementptr i8, i8 addrspace(200)* null, i64 [[GEPOFF]]
; FLAGS-NEXT:    [[RET:%.*]] = tail call i8 addrspace(200)* @llvm.cheri.cap.flags.set.i64(i8 addrspace(200)* [[TMP]], i64 [[VALUE]])
; FLAGS-NEXT:    ret i8 addrspace(200)* [[RET]]
;
; HIGH-LABEL: define {{[^@]+}}@fold_set_on_null_with_gep
; HIGH-SAME: (i64 [[VALUE:%.*]], i64 [[GEPOFF:%.*]]) addrspace(200) #[[ATTR0]] {
; HIGH-NEXT:    [[TMP:%.*]] = getelementptr i8, i8 addrspace(200)* null, i64 [[GEPOFF]]
; HIGH-NEXT:    [[RET:%.*]] = tail call i8 addrspace(200)* @llvm.cheri.cap.high.set.i64(i8 addrspace(200)* [[TMP]], i64 [[VALUE]])
; HIGH-NEXT:    ret i8 addrspace(200)* [[RET]]
;
; OFFSET-LABEL: define {{[^@]+}}@fold_set_on_null_with_gep
; OFFSET-SAME: (i64 [[VALUE:%.*]], i64 [[GEPOFF:%.*]]) addrspace(200) #[[ATTR0]] {
; OFFSET-NEXT:    [[TMP:%.*]] = getelementptr i8, i8 addrspace(200)* null, i64 [[GEPOFF]]
; OFFSET-NEXT:    [[RET:%.*]] = tail call i8 addrspace(200)* @llvm.cheri.cap.offset.set.i64(i8 addrspace(200)* [[TMP]], i64 [[VALUE]])
; OFFSET-NEXT:    ret i8 addrspace(200)* [[RET]]
;
  %tmp = getelementptr i8, i8 addrspace(200)* null, i64 %gepoff
  %ret = tail call i8 addrspace(200)* @llvm.cheri.cap.INTRINSIC.set.i64(i8 addrspace(200)* %tmp, i64 %value)
  ret i8 addrspace(200)* %ret
}
