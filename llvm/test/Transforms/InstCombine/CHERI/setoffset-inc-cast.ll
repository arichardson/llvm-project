; NOTE: Assertions have been autogenerated by utils/update_test_checks.py UTC_ARGS: --function-signature --scrub-attributes
; RUN: opt -S -passes=instcombine %s -o - | FileCheck %s
; RUNNOT: opt -S -passes=instcombine -o - < %s | %riscv64_cheri_purecap_llc -o %t-ic.ll
; RUNNOT: %riscv64_cheri_purecap_llc < %s -o %t-no-ic.ll
; RUNNOT: diff -u %t-ic.ll %t-no-ic.ll
; Check that we handle folding of setoffset followed by bitcast+GEP sensibly
target datalayout = "E-m:e-pf200:128:128:128:64-i8:8:32-i16:16:32-i64:64-n32:64-S128-A200-P200-G200"

%struct.pluto = type { ptr addrspace(200), ptr addrspace(200) }

@foo = addrspace(200) global %struct.pluto zeroinitializer

; Function Attrs: nounwind willreturn memory(none)
declare i64 @llvm.cheri.cap.offset.get.i64(ptr addrspace(200)) addrspace(200) #0

; Function Attrs: nounwind willreturn memory(none)
declare i64 @llvm.cheri.cap.address.get.i64(ptr addrspace(200)) addrspace(200) #0

; Function Attrs: nounwind willreturn memory(none)
declare ptr addrspace(200) @llvm.cheri.cap.offset.set.i64(ptr addrspace(200), i64) addrspace(200) #0

; Function Attrs: nounwind willreturn memory(none)
declare ptr addrspace(200) @llvm.cheri.cap.address.set.i64(ptr addrspace(200), i64) addrspace(200) #0

; Function Attrs: nounwind
define void @no_fold_nonconstant_offset_gep_zero(ptr addrspace(200) %arg, i64 %offset) addrspace(200) #1 {
; CHECK-LABEL: define {{[^@]+}}@no_fold_nonconstant_offset_gep_zero
; CHECK-SAME: (ptr addrspace(200) [[ARG:%.*]], i64 [[OFFSET:%.*]]) addrspace(200) #[[ATTR1:[0-9]+]] {
; CHECK-NEXT:  bb:
; CHECK-NEXT:    [[TMP:%.*]] = call ptr addrspace(200) @llvm.cheri.cap.offset.set.i64(ptr addrspace(200) nonnull @foo, i64 [[OFFSET]])
; CHECK-NEXT:    store ptr addrspace(200) [[ARG]], ptr addrspace(200) [[TMP]], align 16
; CHECK-NEXT:    ret void
;
bb:
  %tmp = call ptr addrspace(200) @llvm.cheri.cap.offset.set.i64(ptr addrspace(200) @foo, i64 %offset)
  %tmp7 = bitcast ptr addrspace(200) %tmp to ptr addrspace(200)
  %tmp5 = getelementptr inbounds %struct.pluto, ptr addrspace(200) %tmp7, i64 0, i32 0
  store ptr addrspace(200) %arg, ptr addrspace(200) %tmp5, align 16
  ret void
}

; Function Attrs: nounwind
define void @no_fold_nonconstant_offset_gep_one(ptr addrspace(200) %arg, i64 %offset) addrspace(200) #1 {
; CHECK-LABEL: define {{[^@]+}}@no_fold_nonconstant_offset_gep_one
; CHECK-SAME: (ptr addrspace(200) [[ARG:%.*]], i64 [[OFFSET:%.*]]) addrspace(200) #[[ATTR1]] {
; CHECK-NEXT:  bb:
; CHECK-NEXT:    [[TMP:%.*]] = call ptr addrspace(200) @llvm.cheri.cap.offset.set.i64(ptr addrspace(200) nonnull @foo, i64 [[OFFSET]])
; CHECK-NEXT:    [[TMP5:%.*]] = getelementptr inbounds [[STRUCT_PLUTO:%.*]], ptr addrspace(200) [[TMP]], i64 0, i32 1
; CHECK-NEXT:    store ptr addrspace(200) [[ARG]], ptr addrspace(200) [[TMP5]], align 16
; CHECK-NEXT:    ret void
;
bb:
  %tmp = call ptr addrspace(200) @llvm.cheri.cap.offset.set.i64(ptr addrspace(200) @foo, i64 %offset)
  %tmp7 = bitcast ptr addrspace(200) %tmp to ptr addrspace(200)
  %tmp5 = getelementptr inbounds %struct.pluto, ptr addrspace(200) %tmp7, i64 0, i32 1
  store ptr addrspace(200) %arg, ptr addrspace(200) %tmp5, align 16
  ret void
}

; Function Attrs: nounwind
define void @no_fold_zero_offset_gep_zero(ptr addrspace(200) %arg) addrspace(200) #1 {
; CHECK-LABEL: define {{[^@]+}}@no_fold_zero_offset_gep_zero
; CHECK-SAME: (ptr addrspace(200) [[ARG:%.*]]) addrspace(200) #[[ATTR1]] {
; CHECK-NEXT:  bb:
; CHECK-NEXT:    [[TMP:%.*]] = call ptr addrspace(200) @llvm.cheri.cap.offset.set.i64(ptr addrspace(200) nonnull @foo, i64 0)
; CHECK-NEXT:    store ptr addrspace(200) [[ARG]], ptr addrspace(200) [[TMP]], align 16
; CHECK-NEXT:    ret void
;
bb:
  %tmp = call ptr addrspace(200) @llvm.cheri.cap.offset.set.i64(ptr addrspace(200) @foo, i64 0)
  %tmp7 = bitcast ptr addrspace(200) %tmp to ptr addrspace(200)
  %tmp5 = getelementptr inbounds %struct.pluto, ptr addrspace(200) %tmp7, i64 0, i32 0
  store ptr addrspace(200) %arg, ptr addrspace(200) %tmp5, align 16
  ret void
}

; Function Attrs: nounwind
define void @no_fold_zero_offset_gep_one(ptr addrspace(200) %arg) addrspace(200) #1 {
; CHECK-LABEL: define {{[^@]+}}@no_fold_zero_offset_gep_one
; CHECK-SAME: (ptr addrspace(200) [[ARG:%.*]]) addrspace(200) #[[ATTR1]] {
; CHECK-NEXT:  bb:
; CHECK-NEXT:    [[TMP:%.*]] = call ptr addrspace(200) @llvm.cheri.cap.offset.set.i64(ptr addrspace(200) nonnull @foo, i64 0)
; CHECK-NEXT:    [[TMP5:%.*]] = getelementptr inbounds [[STRUCT_PLUTO:%.*]], ptr addrspace(200) [[TMP]], i64 0, i32 1
; CHECK-NEXT:    store ptr addrspace(200) [[ARG]], ptr addrspace(200) [[TMP5]], align 16
; CHECK-NEXT:    ret void
;
bb:
  %tmp = call ptr addrspace(200) @llvm.cheri.cap.offset.set.i64(ptr addrspace(200) @foo, i64 0)
  %tmp7 = bitcast ptr addrspace(200) %tmp to ptr addrspace(200)
  %tmp5 = getelementptr inbounds %struct.pluto, ptr addrspace(200) %tmp7, i64 0, i32 1
  store ptr addrspace(200) %arg, ptr addrspace(200) %tmp5, align 16
  ret void
}

; Function Attrs: nounwind
define void @fold_nonzero_offset_gep_zero(ptr addrspace(200) %arg) addrspace(200) #1 {
; CHECK-LABEL: define {{[^@]+}}@fold_nonzero_offset_gep_zero
; CHECK-SAME: (ptr addrspace(200) [[ARG:%.*]]) addrspace(200) #[[ATTR1]] {
; CHECK-NEXT:  bb:
; CHECK-NEXT:    [[TMP:%.*]] = call ptr addrspace(200) @llvm.cheri.cap.offset.set.i64(ptr addrspace(200) nonnull @foo, i64 16)
; CHECK-NEXT:    store ptr addrspace(200) [[ARG]], ptr addrspace(200) [[TMP]], align 16
; CHECK-NEXT:    ret void
;
bb:
  %tmp = call ptr addrspace(200) @llvm.cheri.cap.offset.set.i64(ptr addrspace(200) @foo, i64 16)
  %tmp7 = bitcast ptr addrspace(200) %tmp to ptr addrspace(200)
  %tmp5 = getelementptr inbounds %struct.pluto, ptr addrspace(200) %tmp7, i64 0, i32 0
  store ptr addrspace(200) %arg, ptr addrspace(200) %tmp5, align 16
  ret void
}

; Function Attrs: nounwind
define void @fold_nonzero_offset_gep_one(ptr addrspace(200) %arg) addrspace(200) #1 {
; CHECK-LABEL: define {{[^@]+}}@fold_nonzero_offset_gep_one
; CHECK-SAME: (ptr addrspace(200) [[ARG:%.*]]) addrspace(200) #[[ATTR1]] {
; CHECK-NEXT:  bb:
; CHECK-NEXT:    [[TMP:%.*]] = call ptr addrspace(200) @llvm.cheri.cap.offset.set.i64(ptr addrspace(200) nonnull @foo, i64 32)
; CHECK-NEXT:    store ptr addrspace(200) [[ARG]], ptr addrspace(200) [[TMP]], align 16
; CHECK-NEXT:    ret void
;
bb:
  %tmp = call ptr addrspace(200) @llvm.cheri.cap.offset.set.i64(ptr addrspace(200) @foo, i64 16)
  %tmp7 = bitcast ptr addrspace(200) %tmp to ptr addrspace(200)
  %tmp5 = getelementptr inbounds %struct.pluto, ptr addrspace(200) %tmp7, i64 0, i32 1
  store ptr addrspace(200) %arg, ptr addrspace(200) %tmp5, align 16
  ret void
}

attributes #0 = { nounwind willreturn memory(none) }
attributes #1 = { nounwind }
