; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py
; RUN: %cheri_llc -o - -stop-after=cheri-range-checker %s | FileCheck %s -check-prefix RANGE-CHECKER
; RUN: %cheri_llc -o - %s | FileCheck %s

; ModuleID = '/Users/alex/cheri/llvm-project/clang/test/CodeGen/cheri/hybrid-abi-missed-bounds-violation-inline.c'
@.str = private unnamed_addr constant [23 x i8] c"tag : %d, cap len: %d\0A\00", align 1
@.str.1 = private unnamed_addr constant [9 x i8] c"val: %d\0A\00", align 1

; Function Attrs: nounwind
define signext i32 @test() local_unnamed_addr nounwind {
; CHECK-LABEL: test:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    daddiu $sp, $sp, -48
; CHECK-NEXT:    sd $ra, 40($sp) # 8-byte Folded Spill
; CHECK-NEXT:    csc $c17, $sp, 16($ddc) # 16-byte Folded Spill
; CHECK-NEXT:    addiu $1, $zero, 7
; CHECK-NEXT:    sw $1, 12($sp)
; CHECK-NEXT:    daddiu $1, $sp, 12
; CHECK-NEXT:    cfromddc $c1, $1
; CHECK-NEXT:    csetbounds $c17, $c1, 4
; CHECK-NEXT:    cgetlen $6, $c17
; CHECK-NEXT:    cgettag $5, $c17
; CHECK-NEXT:    sll $6, $6, 0
; CHECK-NEXT:    lui $1, %highest(.L.str)
; CHECK-NEXT:    daddiu $1, $1, %higher(.L.str)
; CHECK-NEXT:    dsll $1, $1, 16
; CHECK-NEXT:    daddiu $1, $1, %hi(.L.str)
; CHECK-NEXT:    dsll $1, $1, 16
; CHECK-NEXT:    jal printf
; CHECK-NEXT:    daddiu $4, $1, %lo(.L.str)
; CHECK-NEXT:    clw $5, $zero, 4($c17)
; CHECK-NEXT:    lui $1, %highest(.L.str.1)
; CHECK-NEXT:    daddiu $1, $1, %higher(.L.str.1)
; CHECK-NEXT:    dsll $1, $1, 16
; CHECK-NEXT:    daddiu $1, $1, %hi(.L.str.1)
; CHECK-NEXT:    dsll $1, $1, 16
; CHECK-NEXT:    jal printf
; CHECK-NEXT:    daddiu $4, $1, %lo(.L.str.1)
; CHECK-NEXT:    daddiu $2, $zero, 0
; CHECK-NEXT:    clc $c17, $sp, 16($ddc) # 16-byte Folded Reload
; CHECK-NEXT:    ld $ra, 40($sp) # 8-byte Folded Reload
; CHECK-NEXT:    jr $ra
; CHECK-NEXT:    daddiu $sp, $sp, 48
entry:
  %i = alloca i32, align 4
  %0 = bitcast ptr %i to ptr
  call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %0)
  store i32 7, ptr %i, align 4
  %1 = addrspacecast ptr %0 to ptr addrspace(200)
  %2 = call i64 @llvm.cheri.cap.length.get.i64(ptr addrspace(200) %1)
  %conv = trunc i64 %2 to i32
  %3 = call i1 @llvm.cheri.cap.tag.get(ptr addrspace(200) %1)
  %conv1 = zext i1 %3 to i32
  %call = call signext i32 (ptr, ...) @printf(ptr @.str, i32 signext %conv1, i32 signext %conv)
  %arrayidx8 = getelementptr inbounds i32, ptr %i, i64 1
  %arrayidx = addrspacecast ptr %arrayidx8 to ptr addrspace(200)
  %4 = load i32, ptr addrspace(200) %arrayidx, align 4
  %call2 = call signext i32 (ptr, ...) @printf(ptr @.str.1, i32 signext %4)
  call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %0)
  ret i32 0
}

; RANGE-CHECKER-LABEL:  define signext i32 @test() local_unnamed_addr #0 {
; RANGE-CHECKER-NEXT:  entry:
; RANGE-CHECKER-NEXT:    %i = alloca i32, align 4
; RANGE-CHECKER-NEXT:    %0 = bitcast ptr %i to ptr
; RANGE-CHECKER-NEXT:    call void @llvm.lifetime.start.p0(i64 4, ptr nonnull %0)
; RANGE-CHECKER-NEXT:    store i32 7, ptr %i, align 4
; RANGE-CHECKER-NEXT:    %1 = addrspacecast ptr %i to ptr addrspace(200)
; RANGE-CHECKER-NEXT:    %2 = call ptr addrspace(200) @llvm.cheri.cap.bounds.set.i64(ptr addrspace(200) %1, i64 4)
; RANGE-CHECKER-NEXT:    %3 = call i64 @llvm.cheri.cap.length.get.i64(ptr addrspace(200) %2)
; RANGE-CHECKER-NEXT:    %conv = trunc i64 %3 to i32
; RANGE-CHECKER-NEXT:    %4 = call i1 @llvm.cheri.cap.tag.get(ptr addrspace(200) %2)
; RANGE-CHECKER-NEXT:    %conv1 = zext i1 %4 to i32
; RANGE-CHECKER-NEXT:    %call = call signext i32 (ptr, ...) @printf(ptr @.str, i32 signext %conv1, i32 signext %conv)
; RANGE-CHECKER-NEXT:    %5 = addrspacecast ptr %i to ptr addrspace(200)
; RANGE-CHECKER-NEXT:    %6 = call ptr addrspace(200) @llvm.cheri.cap.bounds.set.i64(ptr addrspace(200) %5, i64 4)
; RANGE-CHECKER-NEXT:    %offs = getelementptr i8, ptr addrspace(200) %6, i64 4
; RANGE-CHECKER-NEXT:    %7 = load i32, ptr addrspace(200) %offs, align 4
; RANGE-CHECKER-NEXT:    %call2 = call signext i32 (ptr, ...) @printf(ptr @.str.1, i32 signext %7)
; RANGE-CHECKER-NEXT:    call void @llvm.lifetime.end.p0(i64 4, ptr nonnull %0)
; RANGE-CHECKER-NEXT:    ret i32 0
; RANGE-CHECKER-NEXT:  }

define signext i32 @test2() local_unnamed_addr nounwind {
; CHECK-LABEL: test2:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    daddiu $sp, $sp, -16
; CHECK-NEXT:    sd $ra, 8($sp) # 8-byte Folded Spill
; CHECK-NEXT:    daddiu $1, $sp, 4
; CHECK-NEXT:    cfromddc $c1, $1
; CHECK-NEXT:    csetbounds $c1, $c1, 4
; CHECK-NEXT:    jal use_cap
; CHECK-NEXT:    cincoffset $c3, $c1, 4
; CHECK-NEXT:    sll $2, $2, 0
; CHECK-NEXT:    ld $ra, 8($sp) # 8-byte Folded Reload
; CHECK-NEXT:    jr $ra
; CHECK-NEXT:    daddiu $sp, $sp, 16
entry:
  %i = alloca i32, align 4
  %arrayidx8 = getelementptr i32, ptr %i, i64 1
  %arrayidx = addrspacecast ptr %arrayidx8 to ptr addrspace(200)
  %call = call signext i32 @use_cap(ptr addrspace(200) %arrayidx)
  ret i32 %call
}

; RANGE-CHECKER-LABEL:  define signext i32 @test2() local_unnamed_addr #0 {
; RANGE-CHECKER-NEXT:  entry:
; RANGE-CHECKER-NEXT:    %i = alloca i32, align 4
; RANGE-CHECKER-NEXT:    %0 = addrspacecast ptr %i to ptr addrspace(200)
; RANGE-CHECKER-NEXT:    %1 = call ptr addrspace(200) @llvm.cheri.cap.bounds.set.i64(ptr addrspace(200) %0, i64 4)
; RANGE-CHECKER-NEXT:    %offs = getelementptr i8, ptr addrspace(200) %1, i64 4
; RANGE-CHECKER-NEXT:    %call = call signext i32 @use_cap(ptr addrspace(200) %offs)
; RANGE-CHECKER-NEXT:    ret i32 %call
; RANGE-CHECKER-NEXT:  }

define signext i32 @test3() local_unnamed_addr nounwind {
; CHECK-LABEL: test3:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    daddiu $sp, $sp, -16
; CHECK-NEXT:    sd $ra, 8($sp) # 8-byte Folded Spill
; CHECK-NEXT:    daddiu $1, $sp, 4
; CHECK-NEXT:    cfromddc $c1, $1
; CHECK-NEXT:    csetbounds $c1, $c1, 4
; CHECK-NEXT:    jal use_cap
; CHECK-NEXT:    cincoffset $c3, $c1, -4
; CHECK-NEXT:    sll $2, $2, 0
; CHECK-NEXT:    ld $ra, 8($sp) # 8-byte Folded Reload
; CHECK-NEXT:    jr $ra
; CHECK-NEXT:    daddiu $sp, $sp, 16
entry:
  %i = alloca i32, align 4
  %arrayidx8 = getelementptr i32, ptr %i, i64 -1
  %arrayidx = addrspacecast ptr %arrayidx8 to ptr addrspace(200)
  %call = call signext i32 @use_cap(ptr addrspace(200) %arrayidx)
  ret i32 %call
}

; RANGE-CHECKER-LABEL:  define signext i32 @test3() local_unnamed_addr #0 {
; RANGE-CHECKER-NEXT:  entry:
; RANGE-CHECKER-NEXT:    %i = alloca i32, align 4
; RANGE-CHECKER-NEXT:    %0 = addrspacecast ptr %i to ptr addrspace(200)
; RANGE-CHECKER-NEXT:    %1 = call ptr addrspace(200) @llvm.cheri.cap.bounds.set.i64(ptr addrspace(200) %0, i64 4)
; RANGE-CHECKER-NEXT:    %offs = getelementptr i8, ptr addrspace(200) %1, i64 -4
; RANGE-CHECKER-NEXT:    %call = call signext i32 @use_cap(ptr addrspace(200) %offs)
; RANGE-CHECKER-NEXT:    ret i32 %call
; RANGE-CHECKER-NEXT:  }

declare void @llvm.lifetime.start.p0(i64 immarg, ptr nocapture)

declare i64 @llvm.cheri.cap.length.get.i64(ptr addrspace(200))

declare i1 @llvm.cheri.cap.tag.get(ptr addrspace(200))

declare signext i32 @printf(ptr nocapture readonly, ...) local_unnamed_addr
declare signext i32 @use_cap(ptr addrspace(200)) local_unnamed_addr


declare void @llvm.lifetime.end.p0(i64 immarg, ptr nocapture) #2
;; NOTE: These prefixes are unused and the list is autogenerated. Do not add tests below this line:
; RANGE-CHECKER: {{.*}}
