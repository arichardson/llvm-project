// NOTE: Assertions have been autogenerated by utils/update_cc_test_checks.py UTC_ARGS: --function-signature

// RUN: %riscv32_cheri_purecap_cc1 -o - -emit-llvm -disable-O0-optnone %s \
// RUN:   | opt -S -passes=mem2reg | FileCheck %s --check-prefixes=CHECK-IL32PC64
// RUN: %riscv64_cheri_purecap_cc1 -o - -emit-llvm -disable-O0-optnone %s \
// RUN:   | opt -S -passes=mem2reg | FileCheck %s --check-prefixes=CHECK-L64PC128

// CHECK-IL32PC64-LABEL: define {{[^@]+}}@callee
// CHECK-IL32PC64-SAME: (i32 noundef [[N:%.*]], ...) addrspace(200) #[[ATTR0:[0-9]+]] {
// CHECK-IL32PC64-NEXT:  entry:
// CHECK-IL32PC64-NEXT:    [[AP:%.*]] = alloca ptr addrspace(200), align 8, addrspace(200)
// CHECK-IL32PC64-NEXT:    call void @llvm.va_start.p200(ptr addrspace(200) [[AP]])
// CHECK-IL32PC64-NEXT:    br label [[FOR_COND:%.*]]
// CHECK-IL32PC64:       for.cond:
// CHECK-IL32PC64-NEXT:    [[N_ADDR_0:%.*]] = phi i32 [ [[N]], [[ENTRY:%.*]] ], [ [[DEC:%.*]], [[FOR_INC:%.*]] ]
// CHECK-IL32PC64-NEXT:    [[CMP:%.*]] = icmp sgt i32 [[N_ADDR_0]], 0
// CHECK-IL32PC64-NEXT:    br i1 [[CMP]], label [[FOR_BODY:%.*]], label [[FOR_END:%.*]]
// CHECK-IL32PC64:       for.body:
// CHECK-IL32PC64-NEXT:    [[ARGP_CUR:%.*]] = load ptr addrspace(200), ptr addrspace(200) [[AP]], align 8
// CHECK-IL32PC64-NEXT:    [[ARGP_NEXT:%.*]] = getelementptr inbounds i8, ptr addrspace(200) [[ARGP_CUR]], i32 4
// CHECK-IL32PC64-NEXT:    store ptr addrspace(200) [[ARGP_NEXT]], ptr addrspace(200) [[AP]], align 8
// CHECK-IL32PC64-NEXT:    [[TMP0:%.*]] = load i32, ptr addrspace(200) [[ARGP_CUR]], align 4
// CHECK-IL32PC64-NEXT:    br label [[FOR_INC]]
// CHECK-IL32PC64:       for.inc:
// CHECK-IL32PC64-NEXT:    [[DEC]] = add nsw i32 [[N_ADDR_0]], -1
// CHECK-IL32PC64-NEXT:    br label [[FOR_COND]], !llvm.loop [[LOOP4:![0-9]+]]
// CHECK-IL32PC64:       for.end:
// CHECK-IL32PC64-NEXT:    [[ARGP_CUR1:%.*]] = load ptr addrspace(200), ptr addrspace(200) [[AP]], align 8
// CHECK-IL32PC64-NEXT:    [[TMP1:%.*]] = call i32 @llvm.cheri.cap.address.get.i32(ptr addrspace(200) [[ARGP_CUR1]])
// CHECK-IL32PC64-NEXT:    [[TMP2:%.*]] = add i32 [[TMP1]], 7
// CHECK-IL32PC64-NEXT:    [[TMP3:%.*]] = and i32 [[TMP2]], -8
// CHECK-IL32PC64-NEXT:    [[ARGP_CUR1_ALIGNED:%.*]] = call ptr addrspace(200) @llvm.cheri.cap.address.set.i32(ptr addrspace(200) [[ARGP_CUR1]], i32 [[TMP3]])
// CHECK-IL32PC64-NEXT:    [[ARGP_NEXT2:%.*]] = getelementptr inbounds i8, ptr addrspace(200) [[ARGP_CUR1_ALIGNED]], i32 8
// CHECK-IL32PC64-NEXT:    store ptr addrspace(200) [[ARGP_NEXT2]], ptr addrspace(200) [[AP]], align 8
// CHECK-IL32PC64-NEXT:    [[TMP4:%.*]] = load ptr addrspace(200), ptr addrspace(200) [[ARGP_CUR1_ALIGNED]], align 8
// CHECK-IL32PC64-NEXT:    call void @llvm.va_end.p200(ptr addrspace(200) [[AP]])
// CHECK-IL32PC64-NEXT:    ret ptr addrspace(200) [[TMP4]]
//
// CHECK-L64PC128-LABEL: define {{[^@]+}}@callee
// CHECK-L64PC128-SAME: (i32 noundef signext [[N:%.*]], ...) addrspace(200) #[[ATTR0:[0-9]+]] {
// CHECK-L64PC128-NEXT:  entry:
// CHECK-L64PC128-NEXT:    [[AP:%.*]] = alloca ptr addrspace(200), align 16, addrspace(200)
// CHECK-L64PC128-NEXT:    call void @llvm.va_start.p200(ptr addrspace(200) [[AP]])
// CHECK-L64PC128-NEXT:    br label [[FOR_COND:%.*]]
// CHECK-L64PC128:       for.cond:
// CHECK-L64PC128-NEXT:    [[N_ADDR_0:%.*]] = phi i32 [ [[N]], [[ENTRY:%.*]] ], [ [[DEC:%.*]], [[FOR_INC:%.*]] ]
// CHECK-L64PC128-NEXT:    [[CMP:%.*]] = icmp sgt i32 [[N_ADDR_0]], 0
// CHECK-L64PC128-NEXT:    br i1 [[CMP]], label [[FOR_BODY:%.*]], label [[FOR_END:%.*]]
// CHECK-L64PC128:       for.body:
// CHECK-L64PC128-NEXT:    [[ARGP_CUR:%.*]] = load ptr addrspace(200), ptr addrspace(200) [[AP]], align 16
// CHECK-L64PC128-NEXT:    [[ARGP_NEXT:%.*]] = getelementptr inbounds i8, ptr addrspace(200) [[ARGP_CUR]], i64 8
// CHECK-L64PC128-NEXT:    store ptr addrspace(200) [[ARGP_NEXT]], ptr addrspace(200) [[AP]], align 16
// CHECK-L64PC128-NEXT:    [[TMP0:%.*]] = load i32, ptr addrspace(200) [[ARGP_CUR]], align 8
// CHECK-L64PC128-NEXT:    br label [[FOR_INC]]
// CHECK-L64PC128:       for.inc:
// CHECK-L64PC128-NEXT:    [[DEC]] = add nsw i32 [[N_ADDR_0]], -1
// CHECK-L64PC128-NEXT:    br label [[FOR_COND]], !llvm.loop [[LOOP4:![0-9]+]]
// CHECK-L64PC128:       for.end:
// CHECK-L64PC128-NEXT:    [[ARGP_CUR1:%.*]] = load ptr addrspace(200), ptr addrspace(200) [[AP]], align 16
// CHECK-L64PC128-NEXT:    [[TMP1:%.*]] = call i64 @llvm.cheri.cap.address.get.i64(ptr addrspace(200) [[ARGP_CUR1]])
// CHECK-L64PC128-NEXT:    [[TMP2:%.*]] = add i64 [[TMP1]], 15
// CHECK-L64PC128-NEXT:    [[TMP3:%.*]] = and i64 [[TMP2]], -16
// CHECK-L64PC128-NEXT:    [[ARGP_CUR1_ALIGNED:%.*]] = call ptr addrspace(200) @llvm.cheri.cap.address.set.i64(ptr addrspace(200) [[ARGP_CUR1]], i64 [[TMP3]])
// CHECK-L64PC128-NEXT:    [[ARGP_NEXT2:%.*]] = getelementptr inbounds i8, ptr addrspace(200) [[ARGP_CUR1_ALIGNED]], i64 16
// CHECK-L64PC128-NEXT:    store ptr addrspace(200) [[ARGP_NEXT2]], ptr addrspace(200) [[AP]], align 16
// CHECK-L64PC128-NEXT:    [[TMP4:%.*]] = load ptr addrspace(200), ptr addrspace(200) [[ARGP_CUR1_ALIGNED]], align 16
// CHECK-L64PC128-NEXT:    call void @llvm.va_end.p200(ptr addrspace(200) [[AP]])
// CHECK-L64PC128-NEXT:    ret ptr addrspace(200) [[TMP4]]
//
void *callee(int n, ...) {
  __builtin_va_list ap;
  void *ret;

  __builtin_va_start(ap, n);

  for (; n > 0; --n)
    __builtin_va_arg(ap, int);

  ret = __builtin_va_arg(ap, void *);

  __builtin_va_end(ap);
  return ret;
}

// CHECK-IL32PC64-LABEL: define {{[^@]+}}@caller
// CHECK-IL32PC64-SAME: (ptr addrspace(200) noundef [[P:%.*]]) addrspace(200) #[[ATTR0]] {
// CHECK-IL32PC64-NEXT:  entry:
// CHECK-IL32PC64-NEXT:    [[CALL:%.*]] = call ptr addrspace(200) (i32, ...) @callee(i32 noundef 4, i32 noundef 1, i32 noundef 2, i32 noundef 3, ptr addrspace(200) noundef [[P]])
// CHECK-IL32PC64-NEXT:    ret ptr addrspace(200) [[CALL]]
//
// CHECK-L64PC128-LABEL: define {{[^@]+}}@caller
// CHECK-L64PC128-SAME: (ptr addrspace(200) noundef [[P:%.*]]) addrspace(200) #[[ATTR0]] {
// CHECK-L64PC128-NEXT:  entry:
// CHECK-L64PC128-NEXT:    [[CALL:%.*]] = call ptr addrspace(200) (i32, ...) @callee(i32 noundef signext 4, i32 noundef signext 1, i32 noundef signext 2, i32 noundef signext 3, ptr addrspace(200) noundef [[P]])
// CHECK-L64PC128-NEXT:    ret ptr addrspace(200) [[CALL]]
//
void *caller(void *p) {
  return callee(4, 1, 2, 3, p);
}

struct S {
  char buf[64];
};

// XXX: This currently reads a %struct.S* not a %struct.S addrspace(200)* from
// the varargs array.
// CHECK-IL32PC64-LABEL: define {{[^@]+}}@callee_S
// CHECK-IL32PC64-SAME: (ptr addrspace(200) noalias sret([[STRUCT_S:%.*]]) align 1 [[AGG_RESULT:%.*]], i32 noundef [[N:%.*]], ...) addrspace(200) #[[ATTR0]] {
// CHECK-IL32PC64-NEXT:  entry:
// CHECK-IL32PC64-NEXT:    [[AP:%.*]] = alloca ptr addrspace(200), align 8, addrspace(200)
// CHECK-IL32PC64-NEXT:    call void @llvm.va_start.p200(ptr addrspace(200) [[AP]])
// CHECK-IL32PC64-NEXT:    br label [[FOR_COND:%.*]]
// CHECK-IL32PC64:       for.cond:
// CHECK-IL32PC64-NEXT:    [[N_ADDR_0:%.*]] = phi i32 [ [[N]], [[ENTRY:%.*]] ], [ [[DEC:%.*]], [[FOR_INC:%.*]] ]
// CHECK-IL32PC64-NEXT:    [[CMP:%.*]] = icmp sgt i32 [[N_ADDR_0]], 0
// CHECK-IL32PC64-NEXT:    br i1 [[CMP]], label [[FOR_BODY:%.*]], label [[FOR_END:%.*]]
// CHECK-IL32PC64:       for.body:
// CHECK-IL32PC64-NEXT:    [[ARGP_CUR:%.*]] = load ptr addrspace(200), ptr addrspace(200) [[AP]], align 8
// CHECK-IL32PC64-NEXT:    [[ARGP_NEXT:%.*]] = getelementptr inbounds i8, ptr addrspace(200) [[ARGP_CUR]], i32 4
// CHECK-IL32PC64-NEXT:    store ptr addrspace(200) [[ARGP_NEXT]], ptr addrspace(200) [[AP]], align 8
// CHECK-IL32PC64-NEXT:    [[TMP0:%.*]] = load i32, ptr addrspace(200) [[ARGP_CUR]], align 4
// CHECK-IL32PC64-NEXT:    br label [[FOR_INC]]
// CHECK-IL32PC64:       for.inc:
// CHECK-IL32PC64-NEXT:    [[DEC]] = add nsw i32 [[N_ADDR_0]], -1
// CHECK-IL32PC64-NEXT:    br label [[FOR_COND]], !llvm.loop [[LOOP6:![0-9]+]]
// CHECK-IL32PC64:       for.end:
// CHECK-IL32PC64-NEXT:    [[ARGP_CUR1:%.*]] = load ptr addrspace(200), ptr addrspace(200) [[AP]], align 8
// CHECK-IL32PC64-NEXT:    [[TMP1:%.*]] = call i32 @llvm.cheri.cap.address.get.i32(ptr addrspace(200) [[ARGP_CUR1]])
// CHECK-IL32PC64-NEXT:    [[TMP2:%.*]] = add i32 [[TMP1]], 7
// CHECK-IL32PC64-NEXT:    [[TMP3:%.*]] = and i32 [[TMP2]], -8
// CHECK-IL32PC64-NEXT:    [[ARGP_CUR1_ALIGNED:%.*]] = call ptr addrspace(200) @llvm.cheri.cap.address.set.i32(ptr addrspace(200) [[ARGP_CUR1]], i32 [[TMP3]])
// CHECK-IL32PC64-NEXT:    [[ARGP_NEXT2:%.*]] = getelementptr inbounds i8, ptr addrspace(200) [[ARGP_CUR1_ALIGNED]], i32 8
// CHECK-IL32PC64-NEXT:    store ptr addrspace(200) [[ARGP_NEXT2]], ptr addrspace(200) [[AP]], align 8
// CHECK-IL32PC64-NEXT:    [[TMP4:%.*]] = load ptr addrspace(200), ptr addrspace(200) [[ARGP_CUR1_ALIGNED]], align 8
// CHECK-IL32PC64-NEXT:    call void @llvm.memcpy.p200.p200.i32(ptr addrspace(200) align 1 [[AGG_RESULT]], ptr addrspace(200) align 1 [[TMP4]], i32 64, i1 false)
// CHECK-IL32PC64-NEXT:    ret void
//
// CHECK-L64PC128-LABEL: define {{[^@]+}}@callee_S
// CHECK-L64PC128-SAME: (ptr addrspace(200) noalias sret([[STRUCT_S:%.*]]) align 1 [[AGG_RESULT:%.*]], i32 noundef signext [[N:%.*]], ...) addrspace(200) #[[ATTR0]] {
// CHECK-L64PC128-NEXT:  entry:
// CHECK-L64PC128-NEXT:    [[AP:%.*]] = alloca ptr addrspace(200), align 16, addrspace(200)
// CHECK-L64PC128-NEXT:    call void @llvm.va_start.p200(ptr addrspace(200) [[AP]])
// CHECK-L64PC128-NEXT:    br label [[FOR_COND:%.*]]
// CHECK-L64PC128:       for.cond:
// CHECK-L64PC128-NEXT:    [[N_ADDR_0:%.*]] = phi i32 [ [[N]], [[ENTRY:%.*]] ], [ [[DEC:%.*]], [[FOR_INC:%.*]] ]
// CHECK-L64PC128-NEXT:    [[CMP:%.*]] = icmp sgt i32 [[N_ADDR_0]], 0
// CHECK-L64PC128-NEXT:    br i1 [[CMP]], label [[FOR_BODY:%.*]], label [[FOR_END:%.*]]
// CHECK-L64PC128:       for.body:
// CHECK-L64PC128-NEXT:    [[ARGP_CUR:%.*]] = load ptr addrspace(200), ptr addrspace(200) [[AP]], align 16
// CHECK-L64PC128-NEXT:    [[ARGP_NEXT:%.*]] = getelementptr inbounds i8, ptr addrspace(200) [[ARGP_CUR]], i64 8
// CHECK-L64PC128-NEXT:    store ptr addrspace(200) [[ARGP_NEXT]], ptr addrspace(200) [[AP]], align 16
// CHECK-L64PC128-NEXT:    [[TMP0:%.*]] = load i32, ptr addrspace(200) [[ARGP_CUR]], align 8
// CHECK-L64PC128-NEXT:    br label [[FOR_INC]]
// CHECK-L64PC128:       for.inc:
// CHECK-L64PC128-NEXT:    [[DEC]] = add nsw i32 [[N_ADDR_0]], -1
// CHECK-L64PC128-NEXT:    br label [[FOR_COND]], !llvm.loop [[LOOP6:![0-9]+]]
// CHECK-L64PC128:       for.end:
// CHECK-L64PC128-NEXT:    [[ARGP_CUR1:%.*]] = load ptr addrspace(200), ptr addrspace(200) [[AP]], align 16
// CHECK-L64PC128-NEXT:    [[TMP1:%.*]] = call i64 @llvm.cheri.cap.address.get.i64(ptr addrspace(200) [[ARGP_CUR1]])
// CHECK-L64PC128-NEXT:    [[TMP2:%.*]] = add i64 [[TMP1]], 15
// CHECK-L64PC128-NEXT:    [[TMP3:%.*]] = and i64 [[TMP2]], -16
// CHECK-L64PC128-NEXT:    [[ARGP_CUR1_ALIGNED:%.*]] = call ptr addrspace(200) @llvm.cheri.cap.address.set.i64(ptr addrspace(200) [[ARGP_CUR1]], i64 [[TMP3]])
// CHECK-L64PC128-NEXT:    [[ARGP_NEXT2:%.*]] = getelementptr inbounds i8, ptr addrspace(200) [[ARGP_CUR1_ALIGNED]], i64 16
// CHECK-L64PC128-NEXT:    store ptr addrspace(200) [[ARGP_NEXT2]], ptr addrspace(200) [[AP]], align 16
// CHECK-L64PC128-NEXT:    [[TMP4:%.*]] = load ptr addrspace(200), ptr addrspace(200) [[ARGP_CUR1_ALIGNED]], align 16
// CHECK-L64PC128-NEXT:    call void @llvm.memcpy.p200.p200.i64(ptr addrspace(200) align 1 [[AGG_RESULT]], ptr addrspace(200) align 1 [[TMP4]], i64 64, i1 false)
// CHECK-L64PC128-NEXT:    ret void
//
struct S callee_S(int n, ...) {
  __builtin_va_list ap;
  struct S ret;

  __builtin_va_start(ap, n);

  for (; n > 0; --n)
    __builtin_va_arg(ap, int);

  ret = __builtin_va_arg(ap, struct S);

  return ret;
}

// CHECK-IL32PC64-LABEL: define {{[^@]+}}@caller_S
// CHECK-IL32PC64-SAME: (ptr addrspace(200) noalias sret([[STRUCT_S:%.*]]) align 1 [[AGG_RESULT:%.*]], ptr addrspace(200) noundef [[S:%.*]]) addrspace(200) #[[ATTR0]] {
// CHECK-IL32PC64-NEXT:  entry:
// CHECK-IL32PC64-NEXT:    [[BYVAL_TEMP:%.*]] = alloca [[STRUCT_S]], align 1, addrspace(200)
// CHECK-IL32PC64-NEXT:    call void @llvm.memcpy.p200.p200.i32(ptr addrspace(200) align 1 [[BYVAL_TEMP]], ptr addrspace(200) align 1 [[S]], i32 64, i1 false)
// CHECK-IL32PC64-NEXT:    call void (ptr addrspace(200), i32, ...) @callee_S(ptr addrspace(200) sret([[STRUCT_S]]) align 1 [[AGG_RESULT]], i32 noundef 4, i32 noundef 1, i32 noundef 2, i32 noundef 3, ptr addrspace(200) noundef [[BYVAL_TEMP]])
// CHECK-IL32PC64-NEXT:    ret void
//
// CHECK-L64PC128-LABEL: define {{[^@]+}}@caller_S
// CHECK-L64PC128-SAME: (ptr addrspace(200) noalias sret([[STRUCT_S:%.*]]) align 1 [[AGG_RESULT:%.*]], ptr addrspace(200) noundef [[S:%.*]]) addrspace(200) #[[ATTR0]] {
// CHECK-L64PC128-NEXT:  entry:
// CHECK-L64PC128-NEXT:    [[BYVAL_TEMP:%.*]] = alloca [[STRUCT_S]], align 1, addrspace(200)
// CHECK-L64PC128-NEXT:    call void @llvm.memcpy.p200.p200.i64(ptr addrspace(200) align 1 [[BYVAL_TEMP]], ptr addrspace(200) align 1 [[S]], i64 64, i1 false)
// CHECK-L64PC128-NEXT:    call void (ptr addrspace(200), i32, ...) @callee_S(ptr addrspace(200) sret([[STRUCT_S]]) align 1 [[AGG_RESULT]], i32 noundef signext 4, i32 noundef signext 1, i32 noundef signext 2, i32 noundef signext 3, ptr addrspace(200) noundef [[BYVAL_TEMP]])
// CHECK-L64PC128-NEXT:    ret void
//
struct S caller_S(struct S s) {
  return callee_S(4, 1, 2, 3, s);
}
