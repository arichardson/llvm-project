// NOTE: Assertions have been autogenerated by utils/update_cc_test_checks.py
// Check that we generate the correct alignment code both for addr and offset uintcap interpretation
// RUN: %cheri_purecap_cc1 -o - -cheri-uintcap=addr %s -emit-llvm -O0 | %cheri_FileCheck %s
// RUN: %cheri_purecap_cc1 -o - -cheri-uintcap=offset %s -emit-llvm -O0 | %cheri_FileCheck %s

// CHECK-LABEL: @c(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[D_ADDR:%.*]] = alloca ptr addrspace(200), align 16, addrspace(200)
// CHECK-NEXT:    [[B:%.*]] = alloca ptr addrspace(200), align 16, addrspace(200)
// CHECK-NEXT:    store ptr addrspace(200) [[D:%.*]], ptr addrspace(200) [[D_ADDR]], align 16
// CHECK-NEXT:    [[ARGP_CUR:%.*]] = load ptr addrspace(200), ptr addrspace(200) [[D_ADDR]], align 16
// CHECK-NEXT:    [[TMP0:%.*]] = getelementptr inbounds i8, ptr addrspace(200) [[ARGP_CUR]], i32 15
// CHECK-NEXT:    [[ARGP_CUR_ALIGNED:%.*]] = call ptr addrspace(200) @llvm.ptrmask.p200.i64(ptr addrspace(200) [[TMP0]], i64 -16)
// CHECK-NEXT:    [[ARGP_NEXT:%.*]] = getelementptr inbounds i8, ptr addrspace(200) [[ARGP_CUR_ALIGNED]], i64 16
// CHECK-NEXT:    store ptr addrspace(200) [[ARGP_NEXT]], ptr addrspace(200) [[D_ADDR]], align 16
// CHECK-NEXT:    [[TMP1:%.*]] = load ptr addrspace(200), ptr addrspace(200) [[ARGP_CUR_ALIGNED]], align 16
// CHECK-NEXT:    store ptr addrspace(200) [[TMP1]], ptr addrspace(200) [[B]], align 16
// CHECK-NEXT:    [[TMP2:%.*]] = load ptr addrspace(200), ptr addrspace(200) [[B]], align 16
// CHECK-NEXT:    [[TMP3:%.*]] = load i32, ptr addrspace(200) [[TMP2]], align 4
// CHECK-NEXT:    ret i32 [[TMP3]]
//
int c(__builtin_va_list d) {
  int* b = __builtin_va_arg(d, int *);
  return *b;
}
