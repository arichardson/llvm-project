// NOTE: Assertions have been autogenerated by utils/update_cc_test_checks.py UTC_ARGS: --function-signature
// Check that we only set bounds on union member expressions in very-aggressive mode
// FIXME: or should it be aggressive vs safe behave instead (i.e. set bounds in aggressive mode)?
// RUN: %cheri_purecap_cc1 -cheri-bounds=subobject-safe -O2 -std=c11 -emit-llvm %s -o - -Rcheri-subobject-bounds -verify=aggressive,expected | FileCheck %s
// RUN: %cheri_purecap_cc1 -cheri-bounds=aggressive -O2 -std=c11 -emit-llvm %s -o - -Rcheri-subobject-bounds -verify=aggressive,expected | FileCheck %s
// RUN: %cheri_purecap_cc1 -cheri-bounds=very-aggressive -O2 -std=c11 -emit-llvm %s -o - -Rcheri-subobject-bounds -verify=very-aggressive,expected | FileCheck %s --check-prefix=VERY-AGGRESSIVE

struct sockaddr {
  char data[16];
};

struct sockaddr_in {
  __INT16_TYPE__ sin_family;
  __UINT16_TYPE__ sin_port;
  __UINT32_TYPE__ sin_addr;
  char sin_zero[8];
};

struct sockaddr_in6 {
    __UINT16_TYPE__ sin6_family;
    __UINT16_TYPE__ sin6_port;
    __UINT32_TYPE__ sin6_flowinfo;
    char sin6_addr[16];
    __UINT32_TYPE__ sin6_scope_id;
};

// Example from CheriBSD:
union sockunion {
  struct sockaddr sa;
  struct sockaddr_in sin;
  struct sockaddr_in6    sin6;
};

_Static_assert(sizeof(union sockunion) == 28, "");

void call(void* arg);

// CHECK-LABEL: define {{[^@]+}}@test
// CHECK-SAME: (ptr addrspace(200) noundef [[UN:%.*]]) local_unnamed_addr addrspace(200) #[[ATTR0:[0-9]+]] {
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[TMP0:%.*]] = tail call ptr addrspace(200) @llvm.cheri.cap.bounds.set.i64(ptr addrspace(200) [[UN]], i64 28)
// CHECK-NEXT:    tail call void @call(ptr addrspace(200) noundef [[TMP0]]) #[[ATTR3:[0-9]+]]
// CHECK-NEXT:    tail call void @call(ptr addrspace(200) noundef [[TMP0]]) #[[ATTR3]]
// CHECK-NEXT:    tail call void @call(ptr addrspace(200) noundef [[TMP0]]) #[[ATTR3]]
// CHECK-NEXT:    ret void
//
// VERY-AGGRESSIVE-LABEL: define {{[^@]+}}@test
// VERY-AGGRESSIVE-SAME: (ptr addrspace(200) noundef [[UN:%.*]]) local_unnamed_addr addrspace(200) #[[ATTR0:[0-9]+]] {
// VERY-AGGRESSIVE-NEXT:  entry:
// VERY-AGGRESSIVE-NEXT:    [[TMP0:%.*]] = tail call ptr addrspace(200) @llvm.cheri.cap.bounds.set.i64(ptr addrspace(200) [[UN]], i64 16)
// VERY-AGGRESSIVE-NEXT:    tail call void @call(ptr addrspace(200) noundef [[TMP0]]) #[[ATTR3:[0-9]+]]
// VERY-AGGRESSIVE-NEXT:    tail call void @call(ptr addrspace(200) noundef [[TMP0]]) #[[ATTR3]]
// VERY-AGGRESSIVE-NEXT:    [[TMP1:%.*]] = tail call ptr addrspace(200) @llvm.cheri.cap.bounds.set.i64(ptr addrspace(200) [[UN]], i64 28)
// VERY-AGGRESSIVE-NEXT:    tail call void @call(ptr addrspace(200) noundef [[TMP1]]) #[[ATTR3]]
// VERY-AGGRESSIVE-NEXT:    ret void
//
void test(union sockunion* un) {
  // For unions only set bounds on individual members for very-aggressive mode and up:
  call(&un->sa); // 28 bytes in < very-aggrssive, otherwise 16
  // aggressive-remark@-1{{using size of containing type 'union sockunion' instead of object type 'struct sockaddr' for subobject bounds on union member}}
  // aggressive-remark@-2{{setting sub-object bounds for pointer to 'struct sockaddr' to 28 bytes}}
  // very-aggressive-remark@-3{{setting sub-object bounds for field 'sa' (pointer to 'struct sockaddr') to 16 bytes}}
  call(&un->sin);
  // aggressive-remark@-1{{using size of containing type 'union sockunion' instead of object type 'struct sockaddr_in' for subobject bounds on union member}}
  // aggressive-remark@-2{{setting sub-object bounds for pointer to 'struct sockaddr_in' to 28 bytes}}
  // very-aggressive-remark@-3{{setting sub-object bounds for field 'sin' (pointer to 'struct sockaddr_in') to 16 bytes}}
  call(&un->sin6);
  // aggressive-remark@-1{{using size of containing type 'union sockunion' instead of object type 'struct sockaddr_in6' for subobject bounds on union member}}
  // aggressive-remark@-2{{setting sub-object bounds for pointer to 'struct sockaddr_in6' to 28 bytes}}
  // very-aggressive-remark@-3{{setting sub-object bounds for field 'sin6' (pointer to 'struct sockaddr_in6') to 28 bytes}}
}

union WithNestedStruct {
  struct {
    int a;
    int b;
  } nested;
  char buffer[64];
};

// CHECK-LABEL: define {{[^@]+}}@test2
// CHECK-SAME: (ptr addrspace(200) noundef [[UN:%.*]]) local_unnamed_addr addrspace(200) #[[ATTR0]] {
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[TMP0:%.*]] = tail call ptr addrspace(200) @llvm.cheri.cap.bounds.set.i64(ptr addrspace(200) [[UN]], i64 4)
// CHECK-NEXT:    tail call void @call(ptr addrspace(200) noundef [[TMP0]]) #[[ATTR3]]
// CHECK-NEXT:    [[B:%.*]] = getelementptr inbounds [[STRUCT_ANON:%.*]], ptr addrspace(200) [[UN]], i64 0, i32 1
// CHECK-NEXT:    [[TMP1:%.*]] = tail call ptr addrspace(200) @llvm.cheri.cap.bounds.set.i64(ptr addrspace(200) nonnull [[B]], i64 4)
// CHECK-NEXT:    tail call void @call(ptr addrspace(200) noundef [[TMP1]]) #[[ATTR3]]
// CHECK-NEXT:    [[TMP2:%.*]] = tail call ptr addrspace(200) @llvm.cheri.cap.bounds.set.i64(ptr addrspace(200) [[UN]], i64 64)
// CHECK-NEXT:    tail call void @call(ptr addrspace(200) noundef [[TMP2]]) #[[ATTR3]]
// CHECK-NEXT:    tail call void @call(ptr addrspace(200) noundef [[TMP2]]) #[[ATTR3]]
// CHECK-NEXT:    ret void
//
// VERY-AGGRESSIVE-LABEL: define {{[^@]+}}@test2
// VERY-AGGRESSIVE-SAME: (ptr addrspace(200) noundef [[UN:%.*]]) local_unnamed_addr addrspace(200) #[[ATTR0]] {
// VERY-AGGRESSIVE-NEXT:  entry:
// VERY-AGGRESSIVE-NEXT:    [[TMP0:%.*]] = tail call ptr addrspace(200) @llvm.cheri.cap.bounds.set.i64(ptr addrspace(200) [[UN]], i64 4)
// VERY-AGGRESSIVE-NEXT:    tail call void @call(ptr addrspace(200) noundef [[TMP0]]) #[[ATTR3]]
// VERY-AGGRESSIVE-NEXT:    [[B:%.*]] = getelementptr inbounds [[STRUCT_ANON:%.*]], ptr addrspace(200) [[UN]], i64 0, i32 1
// VERY-AGGRESSIVE-NEXT:    [[TMP1:%.*]] = tail call ptr addrspace(200) @llvm.cheri.cap.bounds.set.i64(ptr addrspace(200) nonnull [[B]], i64 4)
// VERY-AGGRESSIVE-NEXT:    tail call void @call(ptr addrspace(200) noundef [[TMP1]]) #[[ATTR3]]
// VERY-AGGRESSIVE-NEXT:    [[TMP2:%.*]] = tail call ptr addrspace(200) @llvm.cheri.cap.bounds.set.i64(ptr addrspace(200) [[UN]], i64 8)
// VERY-AGGRESSIVE-NEXT:    tail call void @call(ptr addrspace(200) noundef [[TMP2]]) #[[ATTR3]]
// VERY-AGGRESSIVE-NEXT:    [[TMP3:%.*]] = tail call ptr addrspace(200) @llvm.cheri.cap.bounds.set.i64(ptr addrspace(200) [[UN]], i64 64)
// VERY-AGGRESSIVE-NEXT:    tail call void @call(ptr addrspace(200) noundef [[TMP3]]) #[[ATTR3]]
// VERY-AGGRESSIVE-NEXT:    ret void
//
void test2(union WithNestedStruct* un) {
  // Accessing a member of a nested struct should set bounds
  call(&un->nested.a);
  // aggressive-remark@-1{{setting sub-object bounds for field 'a' (pointer to 'int') to 4 bytes}}
  // very-aggressive-remark@-2{{setting sub-object bounds for field 'a' (pointer to 'int') to 4 bytes}}
  call(&un->nested.b);
  // aggressive-remark@-1{{setting sub-object bounds for field 'b' (pointer to 'int') to 4 bytes}}
  // very-aggressive-remark@-2{{setting sub-object bounds for field 'b' (pointer to 'int') to 4 bytes}}
  // But using the immediate children of the union should not
  call(&un->nested);
  // aggressive-remark-re@-1{{using size of containing type 'union WithNestedStruct' instead of object type 'struct (unnamed struct at {{.+}}subobject-bounds-union.c:{{[0-9]+}}:3)' for subobject bounds on union member}}
  // aggressive-remark-re@-2{{setting sub-object bounds for pointer to 'struct (unnamed struct at {{.+}}subobject-bounds-union.c:{{[0-9]+}}:3)' to 64 bytes}}
  // very-aggressive-remark-re@-3{{setting sub-object bounds for field 'nested' (pointer to 'struct (unnamed struct at {{.+}}subobject-bounds-union.c:{{[0-9]+}}:3)') to 8 bytes}}
  call(&un->buffer);
  // aggressive-remark@-1{{using size of containing type 'union WithNestedStruct' instead of object type 'char[64]' for subobject bounds on union member}}
  // aggressive-remark@-2{{setting sub-object bounds for pointer to 'char[64]' to 64 bytes}}
  // very-aggressive-remark@-3{{etting sub-object bounds for field 'buffer' (pointer to 'char[64]') to 64 bytes}}
}

// Real VLA with empty [] are not allow in unions but the pre-C99 versions with 0/1 might exist

union WithVLA1 {
  int i;
  char vla[0];
  long other_field;
};

union WithVLA2 {
  long l;
  char vla[1];
  long other_field;
};

union WithVLA3 {
  float f;
  struct NestedVLA {
    char vla[1];
  } nestedvla;
  long other_field;
};

// CHECK-LABEL: define {{[^@]+}}@test3
// CHECK-SAME: (ptr addrspace(200) noundef [[UN1:%.*]], ptr addrspace(200) noundef [[UN2:%.*]], ptr addrspace(200) noundef [[UN3:%.*]]) local_unnamed_addr addrspace(200) #[[ATTR0]] {
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[CUR_OFFSET:%.*]] = tail call i64 @llvm.cheri.cap.offset.get.i64(ptr addrspace(200) [[UN1]])
// CHECK-NEXT:    [[CUR_LEN:%.*]] = tail call i64 @llvm.cheri.cap.length.get.i64(ptr addrspace(200) [[UN1]])
// CHECK-NEXT:    [[REMAINING_BYTES:%.*]] = sub i64 [[CUR_LEN]], [[CUR_OFFSET]]
// CHECK-NEXT:    [[TMP0:%.*]] = tail call ptr addrspace(200) @llvm.cheri.cap.bounds.set.i64(ptr addrspace(200) [[UN1]], i64 [[REMAINING_BYTES]])
// CHECK-NEXT:    tail call void @call(ptr addrspace(200) noundef [[TMP0]]) #[[ATTR3]]
// CHECK-NEXT:    [[CUR_OFFSET1:%.*]] = tail call i64 @llvm.cheri.cap.offset.get.i64(ptr addrspace(200) [[UN2]])
// CHECK-NEXT:    [[CUR_LEN2:%.*]] = tail call i64 @llvm.cheri.cap.length.get.i64(ptr addrspace(200) [[UN2]])
// CHECK-NEXT:    [[REMAINING_BYTES3:%.*]] = sub i64 [[CUR_LEN2]], [[CUR_OFFSET1]]
// CHECK-NEXT:    [[TMP1:%.*]] = tail call ptr addrspace(200) @llvm.cheri.cap.bounds.set.i64(ptr addrspace(200) [[UN2]], i64 [[REMAINING_BYTES3]])
// CHECK-NEXT:    tail call void @call(ptr addrspace(200) noundef [[TMP1]]) #[[ATTR3]]
// CHECK-NEXT:    [[CUR_OFFSET4:%.*]] = tail call i64 @llvm.cheri.cap.offset.get.i64(ptr addrspace(200) [[UN3]])
// CHECK-NEXT:    [[CUR_LEN5:%.*]] = tail call i64 @llvm.cheri.cap.length.get.i64(ptr addrspace(200) [[UN3]])
// CHECK-NEXT:    [[REMAINING_BYTES6:%.*]] = sub i64 [[CUR_LEN5]], [[CUR_OFFSET4]]
// CHECK-NEXT:    [[TMP2:%.*]] = tail call ptr addrspace(200) @llvm.cheri.cap.bounds.set.i64(ptr addrspace(200) [[UN3]], i64 [[REMAINING_BYTES6]])
// CHECK-NEXT:    tail call void @call(ptr addrspace(200) noundef [[TMP2]]) #[[ATTR3]]
// CHECK-NEXT:    ret void
//
// VERY-AGGRESSIVE-LABEL: define {{[^@]+}}@test3
// VERY-AGGRESSIVE-SAME: (ptr addrspace(200) noundef [[UN1:%.*]], ptr addrspace(200) noundef [[UN2:%.*]], ptr addrspace(200) noundef [[UN3:%.*]]) local_unnamed_addr addrspace(200) #[[ATTR0]] {
// VERY-AGGRESSIVE-NEXT:  entry:
// VERY-AGGRESSIVE-NEXT:    [[TMP0:%.*]] = tail call ptr addrspace(200) @llvm.cheri.cap.bounds.set.i64(ptr addrspace(200) [[UN1]], i64 4)
// VERY-AGGRESSIVE-NEXT:    tail call void @call(ptr addrspace(200) noundef [[TMP0]]) #[[ATTR3]]
// VERY-AGGRESSIVE-NEXT:    [[TMP1:%.*]] = tail call ptr addrspace(200) @llvm.cheri.cap.bounds.set.i64(ptr addrspace(200) [[UN2]], i64 8)
// VERY-AGGRESSIVE-NEXT:    tail call void @call(ptr addrspace(200) noundef [[TMP1]]) #[[ATTR3]]
// VERY-AGGRESSIVE-NEXT:    [[TMP2:%.*]] = tail call ptr addrspace(200) @llvm.cheri.cap.bounds.set.i64(ptr addrspace(200) [[UN3]], i64 4)
// VERY-AGGRESSIVE-NEXT:    tail call void @call(ptr addrspace(200) noundef [[TMP2]]) #[[ATTR3]]
// VERY-AGGRESSIVE-NEXT:    ret void
//
void test3(union WithVLA1 *un1, union WithVLA2 *un2, union WithVLA3 *un3) {
  // Check that we don't tighten bounds if the union contains a VLA
  // (but still do it in very-aggressive mode)
  call(&un1->i);
  // aggressive-remark@-1{{setting sub-object bounds for field 'i' (pointer to 'int') to remaining bytes (containing union includes a variable length array)}}
  // very-aggressive-remark@-2{{setting sub-object bounds for field 'i' (pointer to 'int') to 4 bytes}}
  call(&un2->l);
  // aggressive-remark@-1{{setting sub-object bounds for field 'l' (pointer to 'long') to remaining bytes (containing union includes a variable length array)}}
  // very-aggressive-remark@-2{{setting sub-object bounds for field 'l' (pointer to 'long') to 8 bytes}}

  // Check that recursing into nested types works
  call(&un3->f);
  // aggressive-remark@-1{{setting sub-object bounds for field 'f' (pointer to 'float') to remaining bytes (containing union includes a variable length array)}}
  // very-aggressive-remark@-2{{setting sub-object bounds for field 'f' (pointer to 'float') to 4 bytes}}
}

/// Regression test for a miscompilation post-LLVM-15 merge: we were setting bounds prior to the GEP in
/// This happened when calling``sx_init_flags(&rm->rm_lock_sx,` which is a
/// macro that expands to setting bounds on a nested union.
struct StructWithNestedUnion {
  char prefix[80];
  union nested {
    struct first { int contents[8]; } first;
    struct second { int contents[4]; } second;
  } nested;
  long other_field;
};

// CHECK-LABEL: define {{[^@]+}}@rmlock_regression
// CHECK-SAME: (ptr addrspace(200) noundef [[S:%.*]]) local_unnamed_addr addrspace(200) #[[ATTR0]] {
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[NESTED:%.*]] = getelementptr inbounds [[STRUCT_STRUCTWITHNESTEDUNION:%.*]], ptr addrspace(200) [[S]], i64 0, i32 1
// CHECK-NEXT:    [[TMP0:%.*]] = tail call ptr addrspace(200) @llvm.cheri.cap.bounds.set.i64(ptr addrspace(200) nonnull [[NESTED]], i64 32)
// CHECK-NEXT:    tail call void @call(ptr addrspace(200) noundef [[TMP0]]) #[[ATTR3]]
// CHECK-NEXT:    tail call void @call(ptr addrspace(200) noundef [[TMP0]]) #[[ATTR3]]
// CHECK-NEXT:    ret void
//
// VERY-AGGRESSIVE-LABEL: define {{[^@]+}}@rmlock_regression
// VERY-AGGRESSIVE-SAME: (ptr addrspace(200) noundef [[S:%.*]]) local_unnamed_addr addrspace(200) #[[ATTR0]] {
// VERY-AGGRESSIVE-NEXT:  entry:
// VERY-AGGRESSIVE-NEXT:    [[NESTED:%.*]] = getelementptr inbounds [[STRUCT_STRUCTWITHNESTEDUNION:%.*]], ptr addrspace(200) [[S]], i64 0, i32 1
// VERY-AGGRESSIVE-NEXT:    [[TMP0:%.*]] = tail call ptr addrspace(200) @llvm.cheri.cap.bounds.set.i64(ptr addrspace(200) nonnull [[NESTED]], i64 32)
// VERY-AGGRESSIVE-NEXT:    tail call void @call(ptr addrspace(200) noundef [[TMP0]]) #[[ATTR3]]
// VERY-AGGRESSIVE-NEXT:    [[TMP1:%.*]] = tail call ptr addrspace(200) @llvm.cheri.cap.bounds.set.i64(ptr addrspace(200) nonnull [[NESTED]], i64 16)
// VERY-AGGRESSIVE-NEXT:    tail call void @call(ptr addrspace(200) noundef [[TMP1]]) #[[ATTR3]]
// VERY-AGGRESSIVE-NEXT:    ret void
//
void rmlock_regression(struct StructWithNestedUnion *s) {
  call(&s->nested.first);
  // aggressive-remark@-1{{using size of containing type 'union nested' instead of object type 'struct first' for subobject bounds on union member}}
  // aggressive-remark@-2{{setting sub-object bounds for pointer to 'struct first' to 32 bytes}}
  // very-aggressive-remark@-3{{setting sub-object bounds for field 'first' (pointer to 'struct first') to 32 bytes}}
  call(&s->nested.second);
  // aggressive-remark@-1{{using size of containing type 'union nested' instead of object type 'struct second' for subobject bounds on union member}}
  // aggressive-remark@-2{{setting sub-object bounds for pointer to 'struct second' to 32 bytes}}
  // very-aggressive-remark@-3{{setting sub-object bounds for field 'second' (pointer to 'struct second') to 16 bytes}}
}
