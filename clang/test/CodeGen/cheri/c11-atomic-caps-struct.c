// NOTE: Assertions have been autogenerated by utils/update_cc_test_checks.py
// UTC_ARGS: --function-signature
// RUN: %riscv64_cheri_cc1 -std=c11 -o - -emit-llvm -disable-O0-optnone -Wno-atomic-alignment %s \
// RUN:   | opt -S -mem2reg | FileCheck --check-prefix=HYBRID-LIBCALLS %s
// RUN: %riscv64_cheri_purecap_cc1 -std=c11 -o - -emit-llvm -disable-O0-optnone -Wno-atomic-alignment %s \
// RUN:   | opt -S -mem2reg | FileCheck --check-prefix=PURECAP-LIBCALLS %s
// RUN: %riscv64_cheri_cc1 -target-feature +a -std=c11 -o - -emit-llvm -disable-O0-optnone -Wno-atomic-alignment %s \
// RUN:   | opt -S -mem2reg | FileCheck --check-prefix=HYBRID %s
// RUN: %riscv64_cheri_purecap_cc1 -target-feature +a -std=c11 -o - -emit-llvm -disable-O0-optnone -Wno-atomic-alignment %s \
// RUN:   | opt -S -mem2reg | FileCheck --check-prefix=PURECAP %s

typedef union capunion {
  long nocap;
  __intcap cap;
} capunion;

// HYBRID-LIBCALLS-LABEL: define {{[^@]+}}@test_init(
// HYBRID-LIBCALLS-NEXT:  entry:
// HYBRID-LIBCALLS-NEXT:    [[VALUE:%.*]] = alloca [[UNION_CAPUNION:%.*]], align 16
// HYBRID-LIBCALLS-NEXT:    [[COERCE_DIVE:%.*]] = getelementptr inbounds [[UNION_CAPUNION]], ptr [[VALUE]], i32 0, i32 0
// HYBRID-LIBCALLS-NEXT:    store ptr addrspace(200) [[VALUE_COERCE:%.*]], ptr [[COERCE_DIVE]], align 16
// HYBRID-LIBCALLS-NEXT:    call void @llvm.memcpy.p0.p0.i64(ptr align 16 [[F:%.*]], ptr align 16 [[VALUE]], i64 16, i1 false)
// HYBRID-LIBCALLS-NEXT:    ret void
//
// PURECAP-LIBCALLS-LABEL: define {{[^@]+}}@test_init(
// PURECAP-LIBCALLS-NEXT:  entry:
// PURECAP-LIBCALLS-NEXT:    [[VALUE:%.*]] = alloca [[UNION_CAPUNION:%.*]], align 16, addrspace(200)
// PURECAP-LIBCALLS-NEXT:    [[COERCE_DIVE:%.*]] = getelementptr inbounds [[UNION_CAPUNION]], ptr addrspace(200) [[VALUE]], i32 0, i32 0
// PURECAP-LIBCALLS-NEXT:    store ptr addrspace(200) [[VALUE_COERCE:%.*]], ptr addrspace(200) [[COERCE_DIVE]], align 16
// PURECAP-LIBCALLS-NEXT:    call void @llvm.memcpy.p200.p200.i64(ptr addrspace(200) align 16 [[F:%.*]], ptr addrspace(200) align 16 [[VALUE]], i64 16, i1 false)
// PURECAP-LIBCALLS-NEXT:    ret void
//
// HYBRID-LABEL: define {{[^@]+}}@test_init(
// HYBRID-NEXT:  entry:
// HYBRID-NEXT:    [[VALUE:%.*]] = alloca [[UNION_CAPUNION:%.*]], align 16
// HYBRID-NEXT:    [[COERCE_DIVE:%.*]] = getelementptr inbounds [[UNION_CAPUNION]], ptr [[VALUE]], i32 0, i32 0
// HYBRID-NEXT:    store ptr addrspace(200) [[VALUE_COERCE:%.*]], ptr [[COERCE_DIVE]], align 16
// HYBRID-NEXT:    call void @llvm.memcpy.p0.p0.i64(ptr align 16 [[F:%.*]], ptr align 16 [[VALUE]], i64 16, i1 false)
// HYBRID-NEXT:    ret void
//
// PURECAP-LABEL: define {{[^@]+}}@test_init(
// PURECAP-NEXT:  entry:
// PURECAP-NEXT:    [[VALUE:%.*]] = alloca [[UNION_CAPUNION:%.*]], align 16, addrspace(200)
// PURECAP-NEXT:    [[COERCE_DIVE:%.*]] = getelementptr inbounds [[UNION_CAPUNION]], ptr addrspace(200) [[VALUE]], i32 0, i32 0
// PURECAP-NEXT:    store ptr addrspace(200) [[VALUE_COERCE:%.*]], ptr addrspace(200) [[COERCE_DIVE]], align 16
// PURECAP-NEXT:    call void @llvm.memcpy.p200.p200.i64(ptr addrspace(200) align 16 [[F:%.*]], ptr addrspace(200) align 16 [[VALUE]], i64 16, i1 false)
// PURECAP-NEXT:    ret void
//
void test_init(_Atomic(capunion) *f, capunion value) {
  __c11_atomic_init(f, value);
}

// HYBRID-LIBCALLS-LABEL: define {{[^@]+}}@test_load(
// HYBRID-LIBCALLS-NEXT:  entry:
// HYBRID-LIBCALLS-NEXT:    [[RETVAL:%.*]] = alloca [[UNION_CAPUNION:%.*]], align 16
// HYBRID-LIBCALLS-NEXT:    [[ATOMIC_TEMP:%.*]] = alloca [[UNION_CAPUNION]], align 16
// HYBRID-LIBCALLS-NEXT:    call void @__atomic_load(i64 noundef 16, ptr noundef [[F:%.*]], ptr noundef [[ATOMIC_TEMP]], i32 noundef signext 5)
// HYBRID-LIBCALLS-NEXT:    call void @llvm.memcpy.p0.p0.i64(ptr align 16 [[RETVAL]], ptr align 16 [[ATOMIC_TEMP]], i64 16, i1 false)
// HYBRID-LIBCALLS-NEXT:    [[TMP0:%.*]] = load [[UNION_CAPUNION]], ptr [[RETVAL]], align 16
// HYBRID-LIBCALLS-NEXT:    ret [[UNION_CAPUNION]] [[TMP0]]
//
// PURECAP-LIBCALLS-LABEL: define {{[^@]+}}@test_load(
// PURECAP-LIBCALLS-NEXT:  entry:
// PURECAP-LIBCALLS-NEXT:    [[RETVAL:%.*]] = alloca [[UNION_CAPUNION:%.*]], align 16, addrspace(200)
// PURECAP-LIBCALLS-NEXT:    [[ATOMIC_TEMP:%.*]] = alloca [[UNION_CAPUNION]], align 16, addrspace(200)
// PURECAP-LIBCALLS-NEXT:    call void @__atomic_load(i64 noundef 16, ptr addrspace(200) noundef [[F:%.*]], ptr addrspace(200) noundef [[ATOMIC_TEMP]], i32 noundef signext 5)
// PURECAP-LIBCALLS-NEXT:    call void @llvm.memcpy.p200.p200.i64(ptr addrspace(200) align 16 [[RETVAL]], ptr addrspace(200) align 16 [[ATOMIC_TEMP]], i64 16, i1 false)
// PURECAP-LIBCALLS-NEXT:    [[TMP0:%.*]] = load [[UNION_CAPUNION]], ptr addrspace(200) [[RETVAL]], align 16
// PURECAP-LIBCALLS-NEXT:    ret [[UNION_CAPUNION]] [[TMP0]]
//
// HYBRID-LABEL: define {{[^@]+}}@test_load(
// HYBRID-NEXT:  entry:
// HYBRID-NEXT:    [[RETVAL:%.*]] = alloca [[UNION_CAPUNION:%.*]], align 16
// HYBRID-NEXT:    [[ATOMIC_TEMP:%.*]] = alloca [[UNION_CAPUNION]], align 16
// HYBRID-NEXT:    call void @__atomic_load(i64 noundef 16, ptr noundef [[F:%.*]], ptr noundef [[ATOMIC_TEMP]], i32 noundef signext 5)
// HYBRID-NEXT:    call void @llvm.memcpy.p0.p0.i64(ptr align 16 [[RETVAL]], ptr align 16 [[ATOMIC_TEMP]], i64 16, i1 false)
// HYBRID-NEXT:    [[TMP0:%.*]] = load [[UNION_CAPUNION]], ptr [[RETVAL]], align 16
// HYBRID-NEXT:    ret [[UNION_CAPUNION]] [[TMP0]]
//
// PURECAP-LABEL: define {{[^@]+}}@test_load(
// PURECAP-NEXT:  entry:
// PURECAP-NEXT:    [[RETVAL:%.*]] = alloca [[UNION_CAPUNION:%.*]], align 16, addrspace(200)
// PURECAP-NEXT:    [[ATOMIC_TEMP:%.*]] = alloca [[UNION_CAPUNION]], align 16, addrspace(200)
// PURECAP-NEXT:    call void @__atomic_load(i64 noundef 16, ptr addrspace(200) noundef [[F:%.*]], ptr addrspace(200) noundef [[ATOMIC_TEMP]], i32 noundef signext 5)
// PURECAP-NEXT:    call void @llvm.memcpy.p200.p200.i64(ptr addrspace(200) align 16 [[RETVAL]], ptr addrspace(200) align 16 [[ATOMIC_TEMP]], i64 16, i1 false)
// PURECAP-NEXT:    [[TMP0:%.*]] = load [[UNION_CAPUNION]], ptr addrspace(200) [[RETVAL]], align 16
// PURECAP-NEXT:    ret [[UNION_CAPUNION]] [[TMP0]]
//
capunion test_load(_Atomic(capunion) *f) {
  return __c11_atomic_load(f, __ATOMIC_SEQ_CST);
}

// HYBRID-LIBCALLS-LABEL: define {{[^@]+}}@test_store(
// HYBRID-LIBCALLS-NEXT:  entry:
// HYBRID-LIBCALLS-NEXT:    [[VALUE:%.*]] = alloca [[UNION_CAPUNION:%.*]], align 16
// HYBRID-LIBCALLS-NEXT:    [[DOTATOMICTMP:%.*]] = alloca [[UNION_CAPUNION]], align 16
// HYBRID-LIBCALLS-NEXT:    [[COERCE_DIVE:%.*]] = getelementptr inbounds [[UNION_CAPUNION]], ptr [[VALUE]], i32 0, i32 0
// HYBRID-LIBCALLS-NEXT:    store ptr addrspace(200) [[VALUE_COERCE:%.*]], ptr [[COERCE_DIVE]], align 16
// HYBRID-LIBCALLS-NEXT:    call void @llvm.memcpy.p0.p0.i64(ptr align 16 [[DOTATOMICTMP]], ptr align 16 [[VALUE]], i64 16, i1 false)
// HYBRID-LIBCALLS-NEXT:    call void @__atomic_store(i64 noundef 16, ptr noundef [[F:%.*]], ptr noundef [[DOTATOMICTMP]], i32 noundef signext 5)
// HYBRID-LIBCALLS-NEXT:    ret void
//
// PURECAP-LIBCALLS-LABEL: define {{[^@]+}}@test_store(
// PURECAP-LIBCALLS-NEXT:  entry:
// PURECAP-LIBCALLS-NEXT:    [[VALUE:%.*]] = alloca [[UNION_CAPUNION:%.*]], align 16, addrspace(200)
// PURECAP-LIBCALLS-NEXT:    [[DOTATOMICTMP:%.*]] = alloca [[UNION_CAPUNION]], align 16, addrspace(200)
// PURECAP-LIBCALLS-NEXT:    [[COERCE_DIVE:%.*]] = getelementptr inbounds [[UNION_CAPUNION]], ptr addrspace(200) [[VALUE]], i32 0, i32 0
// PURECAP-LIBCALLS-NEXT:    store ptr addrspace(200) [[VALUE_COERCE:%.*]], ptr addrspace(200) [[COERCE_DIVE]], align 16
// PURECAP-LIBCALLS-NEXT:    call void @llvm.memcpy.p200.p200.i64(ptr addrspace(200) align 16 [[DOTATOMICTMP]], ptr addrspace(200) align 16 [[VALUE]], i64 16, i1 false)
// PURECAP-LIBCALLS-NEXT:    call void @__atomic_store(i64 noundef 16, ptr addrspace(200) noundef [[F:%.*]], ptr addrspace(200) noundef [[DOTATOMICTMP]], i32 noundef signext 5)
// PURECAP-LIBCALLS-NEXT:    ret void
//
// HYBRID-LABEL: define {{[^@]+}}@test_store(
// HYBRID-NEXT:  entry:
// HYBRID-NEXT:    [[VALUE:%.*]] = alloca [[UNION_CAPUNION:%.*]], align 16
// HYBRID-NEXT:    [[DOTATOMICTMP:%.*]] = alloca [[UNION_CAPUNION]], align 16
// HYBRID-NEXT:    [[COERCE_DIVE:%.*]] = getelementptr inbounds [[UNION_CAPUNION]], ptr [[VALUE]], i32 0, i32 0
// HYBRID-NEXT:    store ptr addrspace(200) [[VALUE_COERCE:%.*]], ptr [[COERCE_DIVE]], align 16
// HYBRID-NEXT:    call void @llvm.memcpy.p0.p0.i64(ptr align 16 [[DOTATOMICTMP]], ptr align 16 [[VALUE]], i64 16, i1 false)
// HYBRID-NEXT:    call void @__atomic_store(i64 noundef 16, ptr noundef [[F:%.*]], ptr noundef [[DOTATOMICTMP]], i32 noundef signext 5)
// HYBRID-NEXT:    ret void
//
// PURECAP-LABEL: define {{[^@]+}}@test_store(
// PURECAP-NEXT:  entry:
// PURECAP-NEXT:    [[VALUE:%.*]] = alloca [[UNION_CAPUNION:%.*]], align 16, addrspace(200)
// PURECAP-NEXT:    [[DOTATOMICTMP:%.*]] = alloca [[UNION_CAPUNION]], align 16, addrspace(200)
// PURECAP-NEXT:    [[COERCE_DIVE:%.*]] = getelementptr inbounds [[UNION_CAPUNION]], ptr addrspace(200) [[VALUE]], i32 0, i32 0
// PURECAP-NEXT:    store ptr addrspace(200) [[VALUE_COERCE:%.*]], ptr addrspace(200) [[COERCE_DIVE]], align 16
// PURECAP-NEXT:    call void @llvm.memcpy.p200.p200.i64(ptr addrspace(200) align 16 [[DOTATOMICTMP]], ptr addrspace(200) align 16 [[VALUE]], i64 16, i1 false)
// PURECAP-NEXT:    call void @__atomic_store(i64 noundef 16, ptr addrspace(200) noundef [[F:%.*]], ptr addrspace(200) noundef [[DOTATOMICTMP]], i32 noundef signext 5)
// PURECAP-NEXT:    ret void
//
void test_store(_Atomic(capunion) *f, capunion value) {
  __c11_atomic_store(f, value, __ATOMIC_SEQ_CST);
}

// HYBRID-LIBCALLS-LABEL: define {{[^@]+}}@test_xchg(
// HYBRID-LIBCALLS-NEXT:  entry:
// HYBRID-LIBCALLS-NEXT:    [[RETVAL:%.*]] = alloca [[UNION_CAPUNION:%.*]], align 16
// HYBRID-LIBCALLS-NEXT:    [[VALUE:%.*]] = alloca [[UNION_CAPUNION]], align 16
// HYBRID-LIBCALLS-NEXT:    [[DOTATOMICTMP:%.*]] = alloca [[UNION_CAPUNION]], align 16
// HYBRID-LIBCALLS-NEXT:    [[ATOMIC_TEMP:%.*]] = alloca [[UNION_CAPUNION]], align 16
// HYBRID-LIBCALLS-NEXT:    [[COERCE_DIVE:%.*]] = getelementptr inbounds [[UNION_CAPUNION]], ptr [[VALUE]], i32 0, i32 0
// HYBRID-LIBCALLS-NEXT:    store ptr addrspace(200) [[VALUE_COERCE:%.*]], ptr [[COERCE_DIVE]], align 16
// HYBRID-LIBCALLS-NEXT:    call void @llvm.memcpy.p0.p0.i64(ptr align 16 [[DOTATOMICTMP]], ptr align 16 [[VALUE]], i64 16, i1 false)
// HYBRID-LIBCALLS-NEXT:    call void @__atomic_exchange(i64 noundef 16, ptr noundef [[F:%.*]], ptr noundef [[DOTATOMICTMP]], ptr noundef [[ATOMIC_TEMP]], i32 noundef signext 5)
// HYBRID-LIBCALLS-NEXT:    call void @llvm.memcpy.p0.p0.i64(ptr align 16 [[RETVAL]], ptr align 16 [[ATOMIC_TEMP]], i64 16, i1 false)
// HYBRID-LIBCALLS-NEXT:    [[TMP0:%.*]] = load [[UNION_CAPUNION]], ptr [[RETVAL]], align 16
// HYBRID-LIBCALLS-NEXT:    ret [[UNION_CAPUNION]] [[TMP0]]
//
// PURECAP-LIBCALLS-LABEL: define {{[^@]+}}@test_xchg(
// PURECAP-LIBCALLS-NEXT:  entry:
// PURECAP-LIBCALLS-NEXT:    [[RETVAL:%.*]] = alloca [[UNION_CAPUNION:%.*]], align 16, addrspace(200)
// PURECAP-LIBCALLS-NEXT:    [[VALUE:%.*]] = alloca [[UNION_CAPUNION]], align 16, addrspace(200)
// PURECAP-LIBCALLS-NEXT:    [[DOTATOMICTMP:%.*]] = alloca [[UNION_CAPUNION]], align 16, addrspace(200)
// PURECAP-LIBCALLS-NEXT:    [[ATOMIC_TEMP:%.*]] = alloca [[UNION_CAPUNION]], align 16, addrspace(200)
// PURECAP-LIBCALLS-NEXT:    [[COERCE_DIVE:%.*]] = getelementptr inbounds [[UNION_CAPUNION]], ptr addrspace(200) [[VALUE]], i32 0, i32 0
// PURECAP-LIBCALLS-NEXT:    store ptr addrspace(200) [[VALUE_COERCE:%.*]], ptr addrspace(200) [[COERCE_DIVE]], align 16
// PURECAP-LIBCALLS-NEXT:    call void @llvm.memcpy.p200.p200.i64(ptr addrspace(200) align 16 [[DOTATOMICTMP]], ptr addrspace(200) align 16 [[VALUE]], i64 16, i1 false)
// PURECAP-LIBCALLS-NEXT:    call void @__atomic_exchange(i64 noundef 16, ptr addrspace(200) noundef [[F:%.*]], ptr addrspace(200) noundef [[DOTATOMICTMP]], ptr addrspace(200) noundef [[ATOMIC_TEMP]], i32 noundef signext 5)
// PURECAP-LIBCALLS-NEXT:    call void @llvm.memcpy.p200.p200.i64(ptr addrspace(200) align 16 [[RETVAL]], ptr addrspace(200) align 16 [[ATOMIC_TEMP]], i64 16, i1 false)
// PURECAP-LIBCALLS-NEXT:    [[TMP0:%.*]] = load [[UNION_CAPUNION]], ptr addrspace(200) [[RETVAL]], align 16
// PURECAP-LIBCALLS-NEXT:    ret [[UNION_CAPUNION]] [[TMP0]]
//
// HYBRID-LABEL: define {{[^@]+}}@test_xchg(
// HYBRID-NEXT:  entry:
// HYBRID-NEXT:    [[RETVAL:%.*]] = alloca [[UNION_CAPUNION:%.*]], align 16
// HYBRID-NEXT:    [[VALUE:%.*]] = alloca [[UNION_CAPUNION]], align 16
// HYBRID-NEXT:    [[DOTATOMICTMP:%.*]] = alloca [[UNION_CAPUNION]], align 16
// HYBRID-NEXT:    [[ATOMIC_TEMP:%.*]] = alloca [[UNION_CAPUNION]], align 16
// HYBRID-NEXT:    [[COERCE_DIVE:%.*]] = getelementptr inbounds [[UNION_CAPUNION]], ptr [[VALUE]], i32 0, i32 0
// HYBRID-NEXT:    store ptr addrspace(200) [[VALUE_COERCE:%.*]], ptr [[COERCE_DIVE]], align 16
// HYBRID-NEXT:    call void @llvm.memcpy.p0.p0.i64(ptr align 16 [[DOTATOMICTMP]], ptr align 16 [[VALUE]], i64 16, i1 false)
// HYBRID-NEXT:    call void @__atomic_exchange(i64 noundef 16, ptr noundef [[F:%.*]], ptr noundef [[DOTATOMICTMP]], ptr noundef [[ATOMIC_TEMP]], i32 noundef signext 5)
// HYBRID-NEXT:    call void @llvm.memcpy.p0.p0.i64(ptr align 16 [[RETVAL]], ptr align 16 [[ATOMIC_TEMP]], i64 16, i1 false)
// HYBRID-NEXT:    [[TMP0:%.*]] = load [[UNION_CAPUNION]], ptr [[RETVAL]], align 16
// HYBRID-NEXT:    ret [[UNION_CAPUNION]] [[TMP0]]
//
// PURECAP-LABEL: define {{[^@]+}}@test_xchg(
// PURECAP-NEXT:  entry:
// PURECAP-NEXT:    [[RETVAL:%.*]] = alloca [[UNION_CAPUNION:%.*]], align 16, addrspace(200)
// PURECAP-NEXT:    [[VALUE:%.*]] = alloca [[UNION_CAPUNION]], align 16, addrspace(200)
// PURECAP-NEXT:    [[DOTATOMICTMP:%.*]] = alloca [[UNION_CAPUNION]], align 16, addrspace(200)
// PURECAP-NEXT:    [[ATOMIC_TEMP:%.*]] = alloca [[UNION_CAPUNION]], align 16, addrspace(200)
// PURECAP-NEXT:    [[COERCE_DIVE:%.*]] = getelementptr inbounds [[UNION_CAPUNION]], ptr addrspace(200) [[VALUE]], i32 0, i32 0
// PURECAP-NEXT:    store ptr addrspace(200) [[VALUE_COERCE:%.*]], ptr addrspace(200) [[COERCE_DIVE]], align 16
// PURECAP-NEXT:    call void @llvm.memcpy.p200.p200.i64(ptr addrspace(200) align 16 [[DOTATOMICTMP]], ptr addrspace(200) align 16 [[VALUE]], i64 16, i1 false)
// PURECAP-NEXT:    call void @__atomic_exchange(i64 noundef 16, ptr addrspace(200) noundef [[F:%.*]], ptr addrspace(200) noundef [[DOTATOMICTMP]], ptr addrspace(200) noundef [[ATOMIC_TEMP]], i32 noundef signext 5)
// PURECAP-NEXT:    call void @llvm.memcpy.p200.p200.i64(ptr addrspace(200) align 16 [[RETVAL]], ptr addrspace(200) align 16 [[ATOMIC_TEMP]], i64 16, i1 false)
// PURECAP-NEXT:    [[TMP0:%.*]] = load [[UNION_CAPUNION]], ptr addrspace(200) [[RETVAL]], align 16
// PURECAP-NEXT:    ret [[UNION_CAPUNION]] [[TMP0]]
//
capunion test_xchg(_Atomic(capunion) *f, capunion value) {
  return __c11_atomic_exchange(f, value, __ATOMIC_SEQ_CST);
}

// HYBRID-LIBCALLS-LABEL: define {{[^@]+}}@test_cmpxchg_weak(
// HYBRID-LIBCALLS-NEXT:  entry:
// HYBRID-LIBCALLS-NEXT:    [[NEW:%.*]] = alloca [[UNION_CAPUNION:%.*]], align 16
// HYBRID-LIBCALLS-NEXT:    [[DOTATOMICTMP:%.*]] = alloca [[UNION_CAPUNION]], align 16
// HYBRID-LIBCALLS-NEXT:    [[COERCE_DIVE:%.*]] = getelementptr inbounds [[UNION_CAPUNION]], ptr [[NEW]], i32 0, i32 0
// HYBRID-LIBCALLS-NEXT:    store ptr addrspace(200) [[NEW_COERCE:%.*]], ptr [[COERCE_DIVE]], align 16
// HYBRID-LIBCALLS-NEXT:    call void @llvm.memcpy.p0.p0.i64(ptr align 16 [[DOTATOMICTMP]], ptr align 16 [[NEW]], i64 16, i1 false)
// HYBRID-LIBCALLS-NEXT:    [[CALL:%.*]] = call zeroext i1 @__atomic_compare_exchange(i64 noundef 16, ptr noundef [[F:%.*]], ptr noundef [[EXP:%.*]], ptr noundef [[DOTATOMICTMP]], i32 noundef signext 0, i32 noundef signext 0)
// HYBRID-LIBCALLS-NEXT:    ret i1 [[CALL]]
//
// PURECAP-LIBCALLS-LABEL: define {{[^@]+}}@test_cmpxchg_weak(
// PURECAP-LIBCALLS-NEXT:  entry:
// PURECAP-LIBCALLS-NEXT:    [[NEW:%.*]] = alloca [[UNION_CAPUNION:%.*]], align 16, addrspace(200)
// PURECAP-LIBCALLS-NEXT:    [[DOTATOMICTMP:%.*]] = alloca [[UNION_CAPUNION]], align 16, addrspace(200)
// PURECAP-LIBCALLS-NEXT:    [[COERCE_DIVE:%.*]] = getelementptr inbounds [[UNION_CAPUNION]], ptr addrspace(200) [[NEW]], i32 0, i32 0
// PURECAP-LIBCALLS-NEXT:    store ptr addrspace(200) [[NEW_COERCE:%.*]], ptr addrspace(200) [[COERCE_DIVE]], align 16
// PURECAP-LIBCALLS-NEXT:    call void @llvm.memcpy.p200.p200.i64(ptr addrspace(200) align 16 [[DOTATOMICTMP]], ptr addrspace(200) align 16 [[NEW]], i64 16, i1 false)
// PURECAP-LIBCALLS-NEXT:    [[CALL:%.*]] = call zeroext i1 @__atomic_compare_exchange(i64 noundef 16, ptr addrspace(200) noundef [[F:%.*]], ptr addrspace(200) noundef [[EXP:%.*]], ptr addrspace(200) noundef [[DOTATOMICTMP]], i32 noundef signext 0, i32 noundef signext 0)
// PURECAP-LIBCALLS-NEXT:    ret i1 [[CALL]]
//
// HYBRID-LABEL: define {{[^@]+}}@test_cmpxchg_weak(
// HYBRID-NEXT:  entry:
// HYBRID-NEXT:    [[NEW:%.*]] = alloca [[UNION_CAPUNION:%.*]], align 16
// HYBRID-NEXT:    [[DOTATOMICTMP:%.*]] = alloca [[UNION_CAPUNION]], align 16
// HYBRID-NEXT:    [[COERCE_DIVE:%.*]] = getelementptr inbounds [[UNION_CAPUNION]], ptr [[NEW]], i32 0, i32 0
// HYBRID-NEXT:    store ptr addrspace(200) [[NEW_COERCE:%.*]], ptr [[COERCE_DIVE]], align 16
// HYBRID-NEXT:    call void @llvm.memcpy.p0.p0.i64(ptr align 16 [[DOTATOMICTMP]], ptr align 16 [[NEW]], i64 16, i1 false)
// HYBRID-NEXT:    [[CALL:%.*]] = call zeroext i1 @__atomic_compare_exchange(i64 noundef 16, ptr noundef [[F:%.*]], ptr noundef [[EXP:%.*]], ptr noundef [[DOTATOMICTMP]], i32 noundef signext 0, i32 noundef signext 0)
// HYBRID-NEXT:    ret i1 [[CALL]]
//
// PURECAP-LABEL: define {{[^@]+}}@test_cmpxchg_weak(
// PURECAP-NEXT:  entry:
// PURECAP-NEXT:    [[NEW:%.*]] = alloca [[UNION_CAPUNION:%.*]], align 16, addrspace(200)
// PURECAP-NEXT:    [[DOTATOMICTMP:%.*]] = alloca [[UNION_CAPUNION]], align 16, addrspace(200)
// PURECAP-NEXT:    [[COERCE_DIVE:%.*]] = getelementptr inbounds [[UNION_CAPUNION]], ptr addrspace(200) [[NEW]], i32 0, i32 0
// PURECAP-NEXT:    store ptr addrspace(200) [[NEW_COERCE:%.*]], ptr addrspace(200) [[COERCE_DIVE]], align 16
// PURECAP-NEXT:    call void @llvm.memcpy.p200.p200.i64(ptr addrspace(200) align 16 [[DOTATOMICTMP]], ptr addrspace(200) align 16 [[NEW]], i64 16, i1 false)
// PURECAP-NEXT:    [[CALL:%.*]] = call zeroext i1 @__atomic_compare_exchange(i64 noundef 16, ptr addrspace(200) noundef [[F:%.*]], ptr addrspace(200) noundef [[EXP:%.*]], ptr addrspace(200) noundef [[DOTATOMICTMP]], i32 noundef signext 0, i32 noundef signext 0)
// PURECAP-NEXT:    ret i1 [[CALL]]
//
_Bool test_cmpxchg_weak(_Atomic(capunion) *f, capunion *exp, capunion new) {
  return __c11_atomic_compare_exchange_weak(f, exp, new, __ATOMIC_RELAXED,
                                            __ATOMIC_RELAXED);
}

// HYBRID-LIBCALLS-LABEL: define {{[^@]+}}@test_cmpxchg_strong(
// HYBRID-LIBCALLS-NEXT:  entry:
// HYBRID-LIBCALLS-NEXT:    [[NEW:%.*]] = alloca [[UNION_CAPUNION:%.*]], align 16
// HYBRID-LIBCALLS-NEXT:    [[DOTATOMICTMP:%.*]] = alloca [[UNION_CAPUNION]], align 16
// HYBRID-LIBCALLS-NEXT:    [[COERCE_DIVE:%.*]] = getelementptr inbounds [[UNION_CAPUNION]], ptr [[NEW]], i32 0, i32 0
// HYBRID-LIBCALLS-NEXT:    store ptr addrspace(200) [[NEW_COERCE:%.*]], ptr [[COERCE_DIVE]], align 16
// HYBRID-LIBCALLS-NEXT:    call void @llvm.memcpy.p0.p0.i64(ptr align 16 [[DOTATOMICTMP]], ptr align 16 [[NEW]], i64 16, i1 false)
// HYBRID-LIBCALLS-NEXT:    [[CALL:%.*]] = call zeroext i1 @__atomic_compare_exchange(i64 noundef 16, ptr noundef [[F:%.*]], ptr noundef [[EXP:%.*]], ptr noundef [[DOTATOMICTMP]], i32 noundef signext 0, i32 noundef signext 0)
// HYBRID-LIBCALLS-NEXT:    ret i1 [[CALL]]
//
// PURECAP-LIBCALLS-LABEL: define {{[^@]+}}@test_cmpxchg_strong(
// PURECAP-LIBCALLS-NEXT:  entry:
// PURECAP-LIBCALLS-NEXT:    [[NEW:%.*]] = alloca [[UNION_CAPUNION:%.*]], align 16, addrspace(200)
// PURECAP-LIBCALLS-NEXT:    [[DOTATOMICTMP:%.*]] = alloca [[UNION_CAPUNION]], align 16, addrspace(200)
// PURECAP-LIBCALLS-NEXT:    [[COERCE_DIVE:%.*]] = getelementptr inbounds [[UNION_CAPUNION]], ptr addrspace(200) [[NEW]], i32 0, i32 0
// PURECAP-LIBCALLS-NEXT:    store ptr addrspace(200) [[NEW_COERCE:%.*]], ptr addrspace(200) [[COERCE_DIVE]], align 16
// PURECAP-LIBCALLS-NEXT:    call void @llvm.memcpy.p200.p200.i64(ptr addrspace(200) align 16 [[DOTATOMICTMP]], ptr addrspace(200) align 16 [[NEW]], i64 16, i1 false)
// PURECAP-LIBCALLS-NEXT:    [[CALL:%.*]] = call zeroext i1 @__atomic_compare_exchange(i64 noundef 16, ptr addrspace(200) noundef [[F:%.*]], ptr addrspace(200) noundef [[EXP:%.*]], ptr addrspace(200) noundef [[DOTATOMICTMP]], i32 noundef signext 0, i32 noundef signext 0)
// PURECAP-LIBCALLS-NEXT:    ret i1 [[CALL]]
//
// HYBRID-LABEL: define {{[^@]+}}@test_cmpxchg_strong(
// HYBRID-NEXT:  entry:
// HYBRID-NEXT:    [[NEW:%.*]] = alloca [[UNION_CAPUNION:%.*]], align 16
// HYBRID-NEXT:    [[DOTATOMICTMP:%.*]] = alloca [[UNION_CAPUNION]], align 16
// HYBRID-NEXT:    [[COERCE_DIVE:%.*]] = getelementptr inbounds [[UNION_CAPUNION]], ptr [[NEW]], i32 0, i32 0
// HYBRID-NEXT:    store ptr addrspace(200) [[NEW_COERCE:%.*]], ptr [[COERCE_DIVE]], align 16
// HYBRID-NEXT:    call void @llvm.memcpy.p0.p0.i64(ptr align 16 [[DOTATOMICTMP]], ptr align 16 [[NEW]], i64 16, i1 false)
// HYBRID-NEXT:    [[CALL:%.*]] = call zeroext i1 @__atomic_compare_exchange(i64 noundef 16, ptr noundef [[F:%.*]], ptr noundef [[EXP:%.*]], ptr noundef [[DOTATOMICTMP]], i32 noundef signext 0, i32 noundef signext 0)
// HYBRID-NEXT:    ret i1 [[CALL]]
//
// PURECAP-LABEL: define {{[^@]+}}@test_cmpxchg_strong(
// PURECAP-NEXT:  entry:
// PURECAP-NEXT:    [[NEW:%.*]] = alloca [[UNION_CAPUNION:%.*]], align 16, addrspace(200)
// PURECAP-NEXT:    [[DOTATOMICTMP:%.*]] = alloca [[UNION_CAPUNION]], align 16, addrspace(200)
// PURECAP-NEXT:    [[COERCE_DIVE:%.*]] = getelementptr inbounds [[UNION_CAPUNION]], ptr addrspace(200) [[NEW]], i32 0, i32 0
// PURECAP-NEXT:    store ptr addrspace(200) [[NEW_COERCE:%.*]], ptr addrspace(200) [[COERCE_DIVE]], align 16
// PURECAP-NEXT:    call void @llvm.memcpy.p200.p200.i64(ptr addrspace(200) align 16 [[DOTATOMICTMP]], ptr addrspace(200) align 16 [[NEW]], i64 16, i1 false)
// PURECAP-NEXT:    [[CALL:%.*]] = call zeroext i1 @__atomic_compare_exchange(i64 noundef 16, ptr addrspace(200) noundef [[F:%.*]], ptr addrspace(200) noundef [[EXP:%.*]], ptr addrspace(200) noundef [[DOTATOMICTMP]], i32 noundef signext 0, i32 noundef signext 0)
// PURECAP-NEXT:    ret i1 [[CALL]]
//
_Bool test_cmpxchg_strong(_Atomic(capunion) *f, capunion *exp, capunion new) {
  return __c11_atomic_compare_exchange_strong(f, exp, new, __ATOMIC_RELAXED,
                                              __ATOMIC_RELAXED);
}
